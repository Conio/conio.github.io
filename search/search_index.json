{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Conio Questo SDK rende semplice integrare un portafoglio Bitcoin Conio nella propria app. Cosa si pu\u00f2 fare? Creare un portafoglio Bitcoin Ottenere le informazioni del portafoglio creato Comprare e Vendere Bitcoin Leggere il dettaglio storico delle operazioni di un utente Ottenere il prezzo storico ed attuale del Bitcoin Come posso utilizzarlo? Installazione Android iOS Configurazione Operazioni Introduzione Operazioni sull'utente Termini di servizio Signup Login Logout Operazioni sul portafoglio Indirizzo bitcoin attuale Lista dei movimenti Dettaglio di un movimento Bilancio del portafoglio Codice di recupero Bitcoin Operazioni sul mercato Prezzo attuale del Bitcoin Prezzo storico del Bitcoin Riepilogo trading Commissioni trading Limiti di trading Acquisto di Bitcoin Vendita di Bitcoin","title":"Home"},{"location":"#conio","text":"Questo SDK rende semplice integrare un portafoglio Bitcoin Conio nella propria app.","title":"Conio"},{"location":"#cosa-si-puo-fare","text":"Creare un portafoglio Bitcoin Ottenere le informazioni del portafoglio creato Comprare e Vendere Bitcoin Leggere il dettaglio storico delle operazioni di un utente Ottenere il prezzo storico ed attuale del Bitcoin","title":"Cosa si pu\u00f2 fare?"},{"location":"#come-posso-utilizzarlo","text":"Installazione Android iOS Configurazione Operazioni Introduzione Operazioni sull'utente Termini di servizio Signup Login Logout Operazioni sul portafoglio Indirizzo bitcoin attuale Lista dei movimenti Dettaglio di un movimento Bilancio del portafoglio Codice di recupero Bitcoin Operazioni sul mercato Prezzo attuale del Bitcoin Prezzo storico del Bitcoin Riepilogo trading Commissioni trading Limiti di trading Acquisto di Bitcoin Vendita di Bitcoin","title":"Come posso utilizzarlo?"},{"location":"CHANGELOG/","text":"Changelog iOS Android iOS 0.2.0 - 06-07-2021 Changed SDK configuration object ConioConfiguration has no default value and must be explicitly initialized Fixed Fix wrong privacy policies url mapping in GetLegalAcceptancesOperation Avoid build error on Xcode 12.4 in OpenAPIConioBuilder 0.1.6 - 25-06-2021 Changed Explicit fees represented as intervals WiretransferPayeeInfo in CreatedBid has now two dedicated properties representing standard and custom wire transfer payee info CreatedBid now contains net cost amount fiatAmount and gross amount grossFiatAmount All fiat amounts are now represented as Decimal 0.1.5 - 15-06-2021 Changed Models update Bid , Ask e Transaction properties linked to amount/balance now are declared with type UInt64 Added ConioError entity to map operation errors 0.1.4 - 10-06-2021 Changed Models update Bid , Ask , WalletBalances e SimpleActivity properties now have public control access Bid , Ask , WalletBalances e SimpleActivity properties linked to amount/balance now are declared with type UInt64 Removed Removed SwiftyRSA from dependencies included in ConioSDK 0.1.3 - 03-06-2021 Fixed Correzione errore signup operation 0.1.0 - 12-04-2021 Added Rilascio versione 0.1.0 Android 0.5.0 - 06-07-2021 Changed SDK configuration object ConioConfiguration has no default value and must be explicitly initialized 0.4.8 - 25-06-2021 Changed Explicit fees represented as intervals WiretransferPayeeInfo in CreatedBid has now two dedicated properties representing standard and custom wire transfer payee info CreatedBid now contains net cost amount fiatAmount and gross amount grossFiatAmount All fiat amounts are now represented as BigDecimal Removed Removed type property from ServiceFee entity Renamed id property of model entities: CreatedAsk.id -> CreatedAsk.askId CreatedBid.id -> CreatedBid.bidId SimpleActivity.id -> SimpleActivity.activityId ActivityDetails.id -> ActivityDetails.activityId Added ConioError : INVALID_CRYPTO_PROOF, CRYPTO_PROOF_EXPIRED 0.4.7 - 01-06-2021 Added Aggiunta di weightedBidBalance alle TradingInfo : controvalore investito modified Modifica alle TradingFees : supporto fasce di commissioni 0.4.2 - 13-04-2021 Added Rilascio versione 0.4.2 0.4.1 - 12-04-2021 Added Rilascio versione 0.4.1","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"iOS Android","title":"Changelog"},{"location":"CHANGELOG/#ios","text":"","title":"iOS"},{"location":"CHANGELOG/#020-06-07-2021","text":"","title":"0.2.0 - 06-07-2021"},{"location":"CHANGELOG/#changed","text":"SDK configuration object ConioConfiguration has no default value and must be explicitly initialized","title":"Changed"},{"location":"CHANGELOG/#fixed","text":"Fix wrong privacy policies url mapping in GetLegalAcceptancesOperation Avoid build error on Xcode 12.4 in OpenAPIConioBuilder","title":"Fixed"},{"location":"CHANGELOG/#016-25-06-2021","text":"","title":"0.1.6 - 25-06-2021"},{"location":"CHANGELOG/#changed_1","text":"Explicit fees represented as intervals WiretransferPayeeInfo in CreatedBid has now two dedicated properties representing standard and custom wire transfer payee info CreatedBid now contains net cost amount fiatAmount and gross amount grossFiatAmount All fiat amounts are now represented as Decimal","title":"Changed"},{"location":"CHANGELOG/#015-15-06-2021","text":"","title":"0.1.5 - 15-06-2021"},{"location":"CHANGELOG/#changed_2","text":"Models update Bid , Ask e Transaction properties linked to amount/balance now are declared with type UInt64","title":"Changed"},{"location":"CHANGELOG/#added","text":"ConioError entity to map operation errors","title":"Added"},{"location":"CHANGELOG/#014-10-06-2021","text":"","title":"0.1.4 - 10-06-2021"},{"location":"CHANGELOG/#changed_3","text":"Models update Bid , Ask , WalletBalances e SimpleActivity properties now have public control access Bid , Ask , WalletBalances e SimpleActivity properties linked to amount/balance now are declared with type UInt64","title":"Changed"},{"location":"CHANGELOG/#removed","text":"Removed SwiftyRSA from dependencies included in ConioSDK","title":"Removed"},{"location":"CHANGELOG/#013-03-06-2021","text":"","title":"0.1.3 - 03-06-2021"},{"location":"CHANGELOG/#fixed_1","text":"Correzione errore signup operation","title":"Fixed"},{"location":"CHANGELOG/#010-12-04-2021","text":"","title":"0.1.0 - 12-04-2021"},{"location":"CHANGELOG/#added_1","text":"Rilascio versione 0.1.0","title":"Added"},{"location":"CHANGELOG/#android","text":"","title":"Android"},{"location":"CHANGELOG/#050-06-07-2021","text":"","title":"0.5.0 - 06-07-2021"},{"location":"CHANGELOG/#changed_4","text":"SDK configuration object ConioConfiguration has no default value and must be explicitly initialized","title":"Changed"},{"location":"CHANGELOG/#048-25-06-2021","text":"","title":"0.4.8 - 25-06-2021"},{"location":"CHANGELOG/#changed_5","text":"Explicit fees represented as intervals WiretransferPayeeInfo in CreatedBid has now two dedicated properties representing standard and custom wire transfer payee info CreatedBid now contains net cost amount fiatAmount and gross amount grossFiatAmount All fiat amounts are now represented as BigDecimal","title":"Changed"},{"location":"CHANGELOG/#removed_1","text":"Removed type property from ServiceFee entity Renamed id property of model entities: CreatedAsk.id -> CreatedAsk.askId CreatedBid.id -> CreatedBid.bidId SimpleActivity.id -> SimpleActivity.activityId ActivityDetails.id -> ActivityDetails.activityId","title":"Removed"},{"location":"CHANGELOG/#added_2","text":"ConioError : INVALID_CRYPTO_PROOF, CRYPTO_PROOF_EXPIRED","title":"Added"},{"location":"CHANGELOG/#047-01-06-2021","text":"","title":"0.4.7 - 01-06-2021"},{"location":"CHANGELOG/#added_3","text":"Aggiunta di weightedBidBalance alle TradingInfo : controvalore investito","title":"Added"},{"location":"CHANGELOG/#modified","text":"Modifica alle TradingFees : supporto fasce di commissioni","title":"modified"},{"location":"CHANGELOG/#042-13-04-2021","text":"","title":"0.4.2 - 13-04-2021"},{"location":"CHANGELOG/#added_4","text":"Rilascio versione 0.4.2","title":"Added"},{"location":"CHANGELOG/#041-12-04-2021","text":"","title":"0.4.1 - 12-04-2021"},{"location":"CHANGELOG/#added_5","text":"Rilascio versione 0.4.1","title":"Added"},{"location":"configuration/Configuration/","text":"Inizializzazione dell'SDK L'oggetto Conio Per usare l'SDK, occorre inizializzare l'oggetto Conio con una ConioConfiguration . La configurazione determiner\u00e0 l'ambiente con il quale l'SDK interagir\u00e0. Possono essere utilizzate due configurazioni principali: test , che si interfaccer\u00e0 con l'ambiente di staging (rete Bitcoin: testnet ). production , che si interfaccer\u00e0 con l'ambiente di produzione (rete Bitcoin: mainnet ). \u00c8 necessario inizializzare l'SDK con un ambiente personalizzato, specificando l'url del backend e la rete Bitcoin da utilizzare. Di seguito le specifiche per inizializzare un oggetto di tipo Conio . Parametri: Conio configuration : di tipo ConioConfiguration , la configurazione per inizializzare l'SDK; (Android) context : di tipo Context , il context dell'applicazione Android. Parametri: ConioConfiguration baseUrl : di tipo String , url del backend; bitcoinNetwork : di tipo BitcoinNetwork , la rete Bitcoin. Pu\u00f2 essere .testnet o .mainnet . Codice Android import com.conio.sdk.Conio; import com.conio.sdk.models.shared.BitcoinNetwork; import com.conio.sdk.models.shared.ConioConfiguration; import com.conio.sdk.providers.networking.NetworkEnvironment; // Test configuration ConioConfiguration testConfig = new ConioConfiguration(\"https://example.test.com\", BitcoinNetwork.TESTNET); Conio conio = new Conio(testConfig, context); // Production configuration ConioConfiguration config = new ConioConfiguration(\"https://example.production.com\", BitcoinNetwork.MAINNET); Conio conio = new Conio(config, context); iOS import ConioSDK // Test configuration let testConfig = ConioConfiguration( withBaseUrl: \"https://example.test.com\", bitcoinNetwork: .testnet ) let conio = Conio(config: testConfig) // Production configuration let config = ConioConfiguration( withBaseUrl: \"https://example.production.com\", bitcoinNetwork: .testnet ) let conio = Conio(config: config)","title":"Configurazione"},{"location":"configuration/Configuration/#inizializzazione-dellsdk","text":"","title":"Inizializzazione dell'SDK"},{"location":"configuration/Configuration/#loggetto-conio","text":"Per usare l'SDK, occorre inizializzare l'oggetto Conio con una ConioConfiguration . La configurazione determiner\u00e0 l'ambiente con il quale l'SDK interagir\u00e0. Possono essere utilizzate due configurazioni principali: test , che si interfaccer\u00e0 con l'ambiente di staging (rete Bitcoin: testnet ). production , che si interfaccer\u00e0 con l'ambiente di produzione (rete Bitcoin: mainnet ). \u00c8 necessario inizializzare l'SDK con un ambiente personalizzato, specificando l'url del backend e la rete Bitcoin da utilizzare. Di seguito le specifiche per inizializzare un oggetto di tipo Conio .","title":"L'oggetto Conio"},{"location":"configuration/Configuration/#parametri-conio","text":"configuration : di tipo ConioConfiguration , la configurazione per inizializzare l'SDK; (Android) context : di tipo Context , il context dell'applicazione Android.","title":"Parametri: Conio"},{"location":"configuration/Configuration/#parametri-conioconfiguration","text":"baseUrl : di tipo String , url del backend; bitcoinNetwork : di tipo BitcoinNetwork , la rete Bitcoin. Pu\u00f2 essere .testnet o .mainnet .","title":"Parametri: ConioConfiguration"},{"location":"configuration/Configuration/#codice","text":"","title":"Codice"},{"location":"configuration/Configuration/#android","text":"import com.conio.sdk.Conio; import com.conio.sdk.models.shared.BitcoinNetwork; import com.conio.sdk.models.shared.ConioConfiguration; import com.conio.sdk.providers.networking.NetworkEnvironment; // Test configuration ConioConfiguration testConfig = new ConioConfiguration(\"https://example.test.com\", BitcoinNetwork.TESTNET); Conio conio = new Conio(testConfig, context); // Production configuration ConioConfiguration config = new ConioConfiguration(\"https://example.production.com\", BitcoinNetwork.MAINNET); Conio conio = new Conio(config, context);","title":"Android"},{"location":"configuration/Configuration/#ios","text":"import ConioSDK // Test configuration let testConfig = ConioConfiguration( withBaseUrl: \"https://example.test.com\", bitcoinNetwork: .testnet ) let conio = Conio(config: testConfig) // Production configuration let config = ConioConfiguration( withBaseUrl: \"https://example.production.com\", bitcoinNetwork: .testnet ) let conio = Conio(config: config)","title":"iOS"},{"location":"exchange/Exchange/","text":"Operazioni sul mercato Prezzo attuale del Bitcoin \u00c8 possibile recuperare il miglior prezzo di acquisto e di vendita attuale del bitcoin, specificando la valuta nel quale lo si vuole ottenere. Inoltre, l'SDK offre la possibilit\u00e0 di convertire un ammontare in bitcoin nella valuta specificata. Metodo exchangeService.currentPrice Parametri Un oggetto di tipo CurrentPriceParams contenente: currency : di tipo Currency , la valuta in cui si vuole ottenere il prezzo; @Opzionale cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) che si vuole convertire nella valuta indicata. Risposta Un CurrentPrice contenente: buyFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il prezzo di acquisto, calcolato nella valuta indicata tramite il campo currency ; sellFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il prezzo di vendita, calcolato nella valuta indicata tramite il campo currency . Codice Android // Example 1: get current price CurrentPriceParams params = new CurrentPriceParams(Currency.EUR); // Example 2: get current price of a specified amount CurrentPriceParams params = new CurrentPriceParams(Currency.EUR, 100000000); conio.exchangeService.currentPrice(params) .asCallback(result -> result.analysis( currentPrice -> { /* Handle CurrentPrice */ }, error -> { /* ... */ } )); iOS // Recupero del prezzo attuale let params = CurrentPriceParams(currency: .eur) // Conversione di 50.000.000 satoshi (0,5 BTC) in euro let params = CurrentPriceParams(currency: .eur, satoshiAmount: 50_000_000) let consumer = conio.exchangeService.currentPrice(params: params) consumer.asCallback { result in switch result { case .success(let prices): // CurrentPrice case .failure(let error): // Operation Error } } Prezzo storico del Bitcoin \u00c8 possibile recuperare il prezzo storico del Bitcoin selezionando una finestra temporale di riferimento. Metodo exchangeService.historicalPrices Parametri Un oggetto di tipo HistoricalPricesParams contenente: currency : di tipo Currency , la valuta in cui si vuole ottenere il prezzo; timeFrame : di tipo TimeFrame , la finestra temporale di riferimento; @Default(24h) interval : di tipo long , l'intervallo che si vuole porre tra i prezzi restituiti; Risposta Un HistoricalPrices contenente: prices : di tipo List<PricePoint> , la lista dei prezzi del bitcoin nella finestra temporale specificata; analytics : di tipo PriceAnalytics , contenente: deltaFiat : di tipo Decimal (iOS) / BigDecimal (Android), la variazione in valuta del prezzo del Bitcoin dall'inizio del periodo di riferimento; deltaPercentage : la variazione in percentuale del prezzo del Bitcoin dall'inizio del periodo di riferimento; trend : di tipo PriceTrend , un enumerato che rappresenta se il prezzo del Bitcoin, dall'inizio del periodo di riferimento, \u00e8 cresciuto, \u00e8 diminuito o \u00e8 rimasto stagnante; Codice Android // Example 1: get last month prices with default interval (1 day) HistoricalPricesParams params = new HistoricalPricesParams( Currency.EUR, TimeFrame.lastMonth() ); // Example 2: get prices from 16th April 2018 to 16th April 2019 with 1 week interval HistoricalPricesParams params = new HistoricalPricesParams( Currency.EUR, new TimeFrame(1523885446000L, 1563465540000L), 604800000 ); conio.exchangeService.historicalPrices(params) .asCallback(result -> result.analysis( prices -> { /* Handle HistoricalPrices */ }, error -> { /* ... */ } )); iOS // Prezzo dal 16 aprile 2019 al 16 aprile 2018 // Intervallo standard: 1 giorno let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000) // Prezzo dal 16 aprile 2019 al 16 aprile 2018 // Intervallo selezionato: 1 settimana let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000, interval: 604800000) let consumer = conio.exchangeService.historicalPrices(params: params) consumer.asCallback { result in switch result { case .success(let prices): // HistoricalPrices case .failure(let error): // Operation Error } } Recupero informazioni di trading Recupero delle informazioni riassuntive delle operazioni di compravendita eseguite dall'utente. Metodo exchangeService.tradingInfo Parametri Un oggetto di tipo TradingInfoParams , contenente: currency : di tipo Currency , la valuta sulla quale si vuole ottenere la risposta; Risposta weightedBidBalance : di tipo Decimal (iOS) / BigDecimal (Android), controvalore investito, calcolato come la media pesata del valore (in valuta fiat) degli acquisti moltiplicato per il bilancio attuale; currency : di tipo Currency , la valuta di riferimento della risposta; bidSummary : di tipo TradingSummary , contenente un riepilogo delle operazioni di acquisto; askSummary : di tipo TradingSummary , contenente un riepilogo delle operazioni di vendita; Le propriet\u00e0 di tipo TradingSummary contengono: operationsCount : di tipo intero , il numero totale di operazioni; totalFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare totale delle operazioni. Codice Android TradingInfoParams params = new TradingInfoParams(Currency.EUR); conio.exchangeService.tradingInfo(params) .asCallback(result -> result.analysis( info -> { /* Handle TradingInfo */ }, error -> { /* ... */ } )); let consumer = conio.exchangeService.tradingInfo() consumer.asCallback { result in switch result { case .success(let info): // Handle TradingInfo case .failure(let error): // Operation Error } } Recupero commissioni di trading Per recuperare le informazioni delle commissioni sulle operazioni di compravendita. Metodo exchangeService.tradingFees Parametri Un oggetto di tipo TradingFeesParams , contenente: currency : di tipo Currency , la valuta sulla quale si vuole ottenere la risposta; Risposta Un oggetto di tipo TradingFees , contenente: currency : di tipo Currency , la valuta di riferimento della risposta; bidServiceFees : di tipo List<ServiceFee> , contenente la lista delle fascie di commissioni per le operazioni di acquisto; askServiceFees : di tipo List<ServiceFee> , contenente la lista delle fascie di commissioni per le operazioni di vendita. Le propriet\u00e0 di tipo ServiceFee contengono: rangeFrom : di tipo Decimal (iOS) / BigDecimal (Android), il valore (in valuta fiat) dal quale viene applicata; @Opzionale percentage : di tipo double , la percentuale di commissione rispetto al valore del operazione, nulla se la ServiceFee rappresenta una commissione assoluta; @Opzionale fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), la commisione assuluta applicata su ogni operazione, nulla se la ServiceFee rappresenta una commissione in percentuale. Codice Android TradingFeesParams params = new TradingFeesParams(Currency.EUR); conio.exchangeService.tradingFees(params) .asCallback(result -> result.analysis( fees -> { /* Handle TradingFees */ }, error -> { /* ... */ } )); let consumer = conio.exchangeService.tradingFees() consumer.asCallback { result in switch result { case .success(let fees): // Handle TradingFees case .failure(let error): // Operation Error } } Recupero limiti di trading Per recuperare i limiti di compravendita associati ad un utente, assegnati in fase di signup tramite il campo userLevel . Metodo exchangeService.tradingLimits Risposta Un oggetto di tipo AllTradingLimits , contenente: buyLimits : di tipo TradingLimits , contenenti informazioni sui limiti di acquisto; sellLimits : di tipo TradingLimits , contenenti informazioni sui limiti di vendita. Le propriet\u00e0 di tipo TradingLimits contengono: minFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il limite minimo attualmente a disposizione; maxFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il limite massimo attualmente a disposizione; allLimits : di tipo List<Limit> , una lista di limiti, ciascuno conterr\u00e0 la rispettiva tipologia ( DAILY , MONTHLY , YEARLY ) ed il valore per ciascuno di essi; currentLimits : di tipo List<Limit> , il valore residuo per ciascuno dei limiti contenuti nell'oggetto allLimits del punto precedente. Codice Android conio.exchangeService.tradingLimits() .asCallback(result -> result.analysis( limits -> { /* Handle AllTradingLimits */ }, error -> { /* ... */ } )); iOS let consumer = conio.exchangeService.tradingLimits() consumer.asCallback { result in switch result { case .success(let fees): // Handle AllTradingLimits case .failure(let error): // Operation Error } } Acquisto di Bitcoin Per poter acquistare dei Bitcoin \u00e8 necessario effettuare due operazioni. La prima \u00e8 quella di creazione di una Bid , ovvero di una richiesta di acquisto di una determinata somma di Bitcoin ad un certo prezzo. All'interno della Bid si troveranno le WiretransferInfo che dovranno essere usate dal client per effettuare il pagamento. Infine si dovr\u00e0 utilizzare la seconda operazione verso Conio per comunicare l'avvenuto pagamento della Bid allegando anche una BidCryptoRequest , generata client side, per testimoniare la legittimit\u00e0 dell'operazione. Creazione della Bid Una Bid si crea specificando la valuta che si intende utilizzare per la transazione e l'importo, o in satoshi o in valuta corrente. Ad esempio, sar\u00e0 quindi possibile richiedere una Bid per l'acquisto di 150\u20ac di Bitcoin o una Bid per l'acquisto di 100.000.000 satoshi. Una volta inviata la richiesta, si otterr\u00e0 una CreatedBid contenente, tra le altre informazioni un bidId . Con questo identificativo sar\u00e0 possibile aggiornare la richiesta di Bid per rimandarne la scadenza e per ottenere le informazioni sul tasso di cambio pi\u00f9 aggiornate. Questo scenario \u00e8 utile nei casi in cui tra la richiesta della Bid e l'effettiva azione dell'utente passi del tempo che renderebbe il tasso di cambio obsoleto. Metodo exchangeService.createOrRefreshBid Parametri Un oggetto di tipo CreateOrRefreshBidParams , costruibile tramite i metodi factory CreateOrRefreshBidParams.fromFiat o CreateOrRefreshBidParams.fromCrypto che richiedono: currency : di tipo Currency , la valuta dell'operazione; amount : di tipo long per .fromCrypto o Decimal (iOS) / BigDecimal (Android) per .fromFiat , l'ammontare, a seconda del metodo usato, in satoshi o nella valuta scelta che si vuole acquistare; @Opzionale bidId : di tipo String , l'id della bid, da valorizzare solo in caso di refresh della bid stessa. Risposta Un oggetto di tipo CreatedBid che contiene: id : di tipo String , l'id utile al refresh o alla finalizzazione della bid; currency : di tipo Currency , la valuta dell'operazione; cryptoAmount : di tipo long , l'ammontare in satoshi della richiesta d'acquisto; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto al netto delle commissioni; grossFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto comprensivo delle commissioni; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni di servizio per la transazione, espresse nella currency di riferimento expiration : di tipo long , il timestamp di scadenza della richiesta di pagamento. Se la bid scade sar\u00e0 necessario aggiornarla per proseguire wireTransferInfo : di tipo WireTransferInfo , le informazioni necessarie per procedere al pagamento della Bid tramite bonifico. Codice Android // Example 1: \u20ac200 bid CreateOrRefreshBidParams params = CreateOrRefreshBidParams.fromFiat(Currency.EUR, 20000); // Example 2: 1.000.000.000 satoshi bid CreateOrRefreshBidParams params = CreateOrRefreshBidParams.fromCrypto(Currency.EUR, 1000000000); conio.exchangeService.createOrRefreshBid(params) .asCallback(result -> result.analysis( bid -> { /* Handle CreatedBid */ }, error -> { /* ... */ } )); iOS // Richiesta d'acquisto per 50\u20ac let params = CreateOrRefreshBidParams(currency: .eur, fiatAmount: 50.0) // Richiesta d'acquisto per 1.000.000 satoshi let params = CreateOrRefreshBidParams(currency: .eur, satoshi: 1000000) // Aggiornamento di una richiesta d'acquisto per 100\u20ac let params = CreateOrRefreshBidParams(bidID: \"bididentifier\", currency: .eur, fiatAmount: 100.0) let consumer = conio.exchangeService.createOrRefreshBid(params: params) consumer.asCallback { result in switch result { case .success(let bid): // Handle CreatedBid case .failure(let error): // Operation Error } } Utilizzo della Bid (pagamento) Una volta effettuato il pagamento tramite bonifico si dovr\u00e0 usare l'operazione purchase per comunicare a Conio l'avvenuto pagamento. Questa operazione richieder\u00e0 una BidCryptoRequest . Metodo exchangeService.purchase Parametri Un oggetto di tipo PurchaseParams contenente: bidId : d tipo String , l'id della Bid da pagare cryptoRequest : di tipo BidCryptoRequest , configurabile come descritto nell'apposita sezione Risposta Un oggetto di tipo Success , che conferma l'avvenuta operazione. Errori INVALID_CRYPTO_PROOF La crypto proof non \u00e8 valida INVALID_PAYMENT_METHOD Il metodo di pagamento non \u00e8 valido UNSUPPORTED_PAYMENT_METHOD Il metodo di pagamento non \u00e8 supportato TRADING_LIMITS_EXCEEDED La bid viola i limiti massimi di acquisto dell'utente TRADE_EXPIRED La bid \u00e8 scaduta BID_ALREADY_PAID La bid \u00e8 gi\u00e0 stata pagata BID_NOT_YET_PAID La bid non \u00e8 ancora stata pagata UNRECOVERABLE_BID La bid \u00e8 in errore FIAT_AMOUNT_TOO_LOW L'importo in Fiat \u00e8 inferiore al limite minimo Codice Android PurchaseParams params = new PurchaseParams(\"bidId\", bidCryptoRequest); conio.exchangeService.purchase(params) .asCallback(result -> result.analysis( success -> { /* Handle Success */ }, error -> { /* ... */ } )); iOS let params = PurchaseParams(bidId: \"bidId\", cryptoRequest: bidCryptoRequest) let consumer = conio.exchangeService.purchase(params: params) consumer.asCallback { result in switch result { case .success: // Handle Success case .failure(let error): // Operation Error } } Vendita di Bitcoin Per poter vendere dei Bitcoin \u00e8 necessario effettuare due operazioni. La prima \u00e8 quella di creazione di una Ask , ovvero di una richiesta di vendita di una determinata somma di Bitcoin ad un certo prezzo. Si procede poi con il pagamento di tale Ask , passando l' askId e allegando anche una AskCryptoRequest , generata client side, per testimoniare la legittimit\u00e0 dell'operazione. L'SDK firmer\u00e0 la transazione che sposter\u00e0 i Bitcoin dal wallet dell'utente, restituendo alla fine l'id della Ask completata. Creazione della Ask Per richiedere una Ask si dovr\u00e0 procedere analogamente a quanto visto per la Bid. Sar\u00e0 quindi possibile richiedere una CreatedAsk per la vendita di 150\u20ac o una per la vendita di 100.000.000 satoshi. Una volta inviata la richiesta, si otterr\u00e0 una CreatedAsk contenente, tra le altre informazioni un askId . Con questo identificativo sar\u00e0 possibile aggiornare la richiesta di Ask per rimandarne la scadenza e per ottenere le informazioni sul tasso di cambio pi\u00f9 aggiornate. Questo scenario \u00e8 utile nei casi in cui tra la richiesta della Ask e l'effettiva azione dell'utente passi del tempo che renderebbe il tasso di cambio obsoleto. Metodo exchangeService.createOrRefreshAsk Parametri Un oggetto di tipo CreateOrRefreshAskParams , costruibile tramite i metodi factory CreateOrRefreshAskParams.fromFiat o CreateOrRefreshAskParams.fromCrypto che richiedono: currency : di tipo Currency , la valuta dell'operazione; amount : di tipo long per .fromCrypto o Decimal (iOS) / BigDecimal (Android) per .fromFiat , l'ammontare, a seconda del metodo usato, in satoshi o nella valuta scelta che si vuole vendere; @Opzionale askId : di tipo String , l'id della ask, da valorizzare solo in caso di refresh della ask stessa. Risposta Un oggetto di tipo CreatedAsk che contiene: askId : di tipo String , l'id utile al refresh o alla finalizzazione della ask; currency : di tipo Currency , la valuta dell'operazione; cryptoAmount : di tipo long , l'ammontare in satoshi della richiesta d'acquisto fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni di servizio per la transazione, espresse nella currency di riferimento; miningFee : di tipo long , le commissioni per scrivere la transazione in blockchain, espresse in satoshi; expiration : di tipo long , lo Unix Timestamp di scadenza della richiesta di pagamento. Se la bid scade sar\u00e0 necessario aggiornarla per proseguire Errori TRADING_LIMITS_EXCEEDED L'utente ha 0 Eur di limiti residui NOT_ENOUGH_BTC_AMOUNT solo se non ha btc L'utente non ha alcun bitcoin NO_SUCH_SELLER Errore interno del sottosistema di vendita NO_SUCH_WALLET Errore interno del sottosistema di wallet Android // Example 1: \u20ac200 ask CreateOrRefreshAskParams params = CreateOrRefreshAskParams.fromFiat(Currency.EUR, BigDecimal(\"200\")); // Example 2: 1.000.000.000 satoshi ask CreateOrRefreshAskParams params = CreateOrRefreshAskParams.fromCrypto(Currency.EUR, 1000000000); conio.exchangeService.createOrRefreshAsk(params) .asCallback(result -> result.analysis( ask -> { /* Handle CreatedAsk */ }, error -> { /* ... */ } )); iOS // Richiesta di vendita per 50\u20ac let params = CreateOrRefreshAskParams(currency: .eur, fiatAmount: 50.0) // Richiesta di vendita per 100000000 satoshi let params = CreateOrRefreshAskParams(currency: .eur, satoshi: 100000000) // Aggiornamento del valore di una Ask esistente let params = CreateOrRefreshAskParams(askID: \"id\", currency: .eur, fiatAmount: 100.0) conio.exchangeService.createOrRefreshAsk(params: params).asCallback { result in switch result { case .success(let createdAsk): // CreatedBid case .failure(let error): // Operation Error } } Utilizzo della Ask Ottenuta la Ask da utilizzare \u00e8 possibile procedere con la finalizzazione della vendita. Per effettuare questa operazione bisogner\u00e0 passare l'ID della CreatedAsk alla Sell operation, insieme alla AskCryptoRequest . Metodo exchangeService.sell Parametri Un oggetto di tipo SellParams contenente: askId : di tipo String , l'id della Ask cryptoRequest : di tipo AskCryptoRequest , configurabile come descritto nell'apposita sezione Risposta Un oggetto di tipo Success che conferma l'avvenuta operazione. Errori TRADING_LIMITS_EXCEEDED La ask viola i limiti massimi di acquisto dell'utente TRADE_EXPIRED La ask \u00e8 scaduta UNRECOVERABLE_ASK La ask \u00e8 in errore ASK_ALREADY_PAID La ask \u00e8 gi\u00e0 stata pagata NOT_ENOUGH_BTC_AMOUNT_E Bitcoin disponibili non sufficienti DUST_ASK Importo in Bitcoin troppo piccolo FIAT_AMOUNT_TOO_LOW Importo in Eur troppo basso Codice Android SellParams params = new SellParams(\"askId\", askCryptoRequest); conio.exchangeService.sell(params) .asCallback(result -> result.analysis( success -> { /* Handle Success */ }, error -> { /* ... */ } )); iOS let params = SellParams(askID: askID) conio.exchangeService.createOrRefreshAsk(params: params).asCallback { result in switch result { case .success: // Handle Succes case .failure(let error): // Operation Error } }","title":"Operazioni sul mercato"},{"location":"exchange/Exchange/#operazioni-sul-mercato","text":"","title":"Operazioni sul mercato"},{"location":"exchange/Exchange/#prezzo-attuale-del-bitcoin","text":"\u00c8 possibile recuperare il miglior prezzo di acquisto e di vendita attuale del bitcoin, specificando la valuta nel quale lo si vuole ottenere. Inoltre, l'SDK offre la possibilit\u00e0 di convertire un ammontare in bitcoin nella valuta specificata.","title":"Prezzo attuale del Bitcoin"},{"location":"exchange/Exchange/#metodo","text":"exchangeService.currentPrice","title":"Metodo"},{"location":"exchange/Exchange/#parametri","text":"Un oggetto di tipo CurrentPriceParams contenente: currency : di tipo Currency , la valuta in cui si vuole ottenere il prezzo; @Opzionale cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) che si vuole convertire nella valuta indicata.","title":"Parametri"},{"location":"exchange/Exchange/#risposta","text":"Un CurrentPrice contenente: buyFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il prezzo di acquisto, calcolato nella valuta indicata tramite il campo currency ; sellFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il prezzo di vendita, calcolato nella valuta indicata tramite il campo currency .","title":"Risposta"},{"location":"exchange/Exchange/#codice","text":"","title":"Codice"},{"location":"exchange/Exchange/#android","text":"// Example 1: get current price CurrentPriceParams params = new CurrentPriceParams(Currency.EUR); // Example 2: get current price of a specified amount CurrentPriceParams params = new CurrentPriceParams(Currency.EUR, 100000000); conio.exchangeService.currentPrice(params) .asCallback(result -> result.analysis( currentPrice -> { /* Handle CurrentPrice */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios","text":"// Recupero del prezzo attuale let params = CurrentPriceParams(currency: .eur) // Conversione di 50.000.000 satoshi (0,5 BTC) in euro let params = CurrentPriceParams(currency: .eur, satoshiAmount: 50_000_000) let consumer = conio.exchangeService.currentPrice(params: params) consumer.asCallback { result in switch result { case .success(let prices): // CurrentPrice case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#prezzo-storico-del-bitcoin","text":"\u00c8 possibile recuperare il prezzo storico del Bitcoin selezionando una finestra temporale di riferimento.","title":"Prezzo storico del Bitcoin"},{"location":"exchange/Exchange/#metodo_1","text":"exchangeService.historicalPrices","title":"Metodo"},{"location":"exchange/Exchange/#parametri_1","text":"Un oggetto di tipo HistoricalPricesParams contenente: currency : di tipo Currency , la valuta in cui si vuole ottenere il prezzo; timeFrame : di tipo TimeFrame , la finestra temporale di riferimento; @Default(24h) interval : di tipo long , l'intervallo che si vuole porre tra i prezzi restituiti;","title":"Parametri"},{"location":"exchange/Exchange/#risposta_1","text":"Un HistoricalPrices contenente: prices : di tipo List<PricePoint> , la lista dei prezzi del bitcoin nella finestra temporale specificata; analytics : di tipo PriceAnalytics , contenente: deltaFiat : di tipo Decimal (iOS) / BigDecimal (Android), la variazione in valuta del prezzo del Bitcoin dall'inizio del periodo di riferimento; deltaPercentage : la variazione in percentuale del prezzo del Bitcoin dall'inizio del periodo di riferimento; trend : di tipo PriceTrend , un enumerato che rappresenta se il prezzo del Bitcoin, dall'inizio del periodo di riferimento, \u00e8 cresciuto, \u00e8 diminuito o \u00e8 rimasto stagnante;","title":"Risposta"},{"location":"exchange/Exchange/#codice_1","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_1","text":"// Example 1: get last month prices with default interval (1 day) HistoricalPricesParams params = new HistoricalPricesParams( Currency.EUR, TimeFrame.lastMonth() ); // Example 2: get prices from 16th April 2018 to 16th April 2019 with 1 week interval HistoricalPricesParams params = new HistoricalPricesParams( Currency.EUR, new TimeFrame(1523885446000L, 1563465540000L), 604800000 ); conio.exchangeService.historicalPrices(params) .asCallback(result -> result.analysis( prices -> { /* Handle HistoricalPrices */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_1","text":"// Prezzo dal 16 aprile 2019 al 16 aprile 2018 // Intervallo standard: 1 giorno let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000) // Prezzo dal 16 aprile 2019 al 16 aprile 2018 // Intervallo selezionato: 1 settimana let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000, interval: 604800000) let consumer = conio.exchangeService.historicalPrices(params: params) consumer.asCallback { result in switch result { case .success(let prices): // HistoricalPrices case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#recupero-informazioni-di-trading","text":"Recupero delle informazioni riassuntive delle operazioni di compravendita eseguite dall'utente.","title":"Recupero informazioni di trading"},{"location":"exchange/Exchange/#metodo_2","text":"exchangeService.tradingInfo","title":"Metodo"},{"location":"exchange/Exchange/#parametri_2","text":"Un oggetto di tipo TradingInfoParams , contenente: currency : di tipo Currency , la valuta sulla quale si vuole ottenere la risposta;","title":"Parametri"},{"location":"exchange/Exchange/#risposta_2","text":"weightedBidBalance : di tipo Decimal (iOS) / BigDecimal (Android), controvalore investito, calcolato come la media pesata del valore (in valuta fiat) degli acquisti moltiplicato per il bilancio attuale; currency : di tipo Currency , la valuta di riferimento della risposta; bidSummary : di tipo TradingSummary , contenente un riepilogo delle operazioni di acquisto; askSummary : di tipo TradingSummary , contenente un riepilogo delle operazioni di vendita; Le propriet\u00e0 di tipo TradingSummary contengono: operationsCount : di tipo intero , il numero totale di operazioni; totalFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare totale delle operazioni.","title":"Risposta"},{"location":"exchange/Exchange/#codice_2","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_2","text":"TradingInfoParams params = new TradingInfoParams(Currency.EUR); conio.exchangeService.tradingInfo(params) .asCallback(result -> result.analysis( info -> { /* Handle TradingInfo */ }, error -> { /* ... */ } )); let consumer = conio.exchangeService.tradingInfo() consumer.asCallback { result in switch result { case .success(let info): // Handle TradingInfo case .failure(let error): // Operation Error } }","title":"Android"},{"location":"exchange/Exchange/#recupero-commissioni-di-trading","text":"Per recuperare le informazioni delle commissioni sulle operazioni di compravendita.","title":"Recupero commissioni di trading"},{"location":"exchange/Exchange/#metodo_3","text":"exchangeService.tradingFees","title":"Metodo"},{"location":"exchange/Exchange/#parametri_3","text":"Un oggetto di tipo TradingFeesParams , contenente: currency : di tipo Currency , la valuta sulla quale si vuole ottenere la risposta;","title":"Parametri"},{"location":"exchange/Exchange/#risposta_3","text":"Un oggetto di tipo TradingFees , contenente: currency : di tipo Currency , la valuta di riferimento della risposta; bidServiceFees : di tipo List<ServiceFee> , contenente la lista delle fascie di commissioni per le operazioni di acquisto; askServiceFees : di tipo List<ServiceFee> , contenente la lista delle fascie di commissioni per le operazioni di vendita. Le propriet\u00e0 di tipo ServiceFee contengono: rangeFrom : di tipo Decimal (iOS) / BigDecimal (Android), il valore (in valuta fiat) dal quale viene applicata; @Opzionale percentage : di tipo double , la percentuale di commissione rispetto al valore del operazione, nulla se la ServiceFee rappresenta una commissione assoluta; @Opzionale fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), la commisione assuluta applicata su ogni operazione, nulla se la ServiceFee rappresenta una commissione in percentuale.","title":"Risposta"},{"location":"exchange/Exchange/#codice_3","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_3","text":"TradingFeesParams params = new TradingFeesParams(Currency.EUR); conio.exchangeService.tradingFees(params) .asCallback(result -> result.analysis( fees -> { /* Handle TradingFees */ }, error -> { /* ... */ } )); let consumer = conio.exchangeService.tradingFees() consumer.asCallback { result in switch result { case .success(let fees): // Handle TradingFees case .failure(let error): // Operation Error } }","title":"Android"},{"location":"exchange/Exchange/#recupero-limiti-di-trading","text":"Per recuperare i limiti di compravendita associati ad un utente, assegnati in fase di signup tramite il campo userLevel .","title":"Recupero limiti di trading"},{"location":"exchange/Exchange/#metodo_4","text":"exchangeService.tradingLimits","title":"Metodo"},{"location":"exchange/Exchange/#risposta_4","text":"Un oggetto di tipo AllTradingLimits , contenente: buyLimits : di tipo TradingLimits , contenenti informazioni sui limiti di acquisto; sellLimits : di tipo TradingLimits , contenenti informazioni sui limiti di vendita. Le propriet\u00e0 di tipo TradingLimits contengono: minFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il limite minimo attualmente a disposizione; maxFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il limite massimo attualmente a disposizione; allLimits : di tipo List<Limit> , una lista di limiti, ciascuno conterr\u00e0 la rispettiva tipologia ( DAILY , MONTHLY , YEARLY ) ed il valore per ciascuno di essi; currentLimits : di tipo List<Limit> , il valore residuo per ciascuno dei limiti contenuti nell'oggetto allLimits del punto precedente.","title":"Risposta"},{"location":"exchange/Exchange/#codice_4","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_4","text":"conio.exchangeService.tradingLimits() .asCallback(result -> result.analysis( limits -> { /* Handle AllTradingLimits */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_2","text":"let consumer = conio.exchangeService.tradingLimits() consumer.asCallback { result in switch result { case .success(let fees): // Handle AllTradingLimits case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#acquisto-di-bitcoin","text":"Per poter acquistare dei Bitcoin \u00e8 necessario effettuare due operazioni. La prima \u00e8 quella di creazione di una Bid , ovvero di una richiesta di acquisto di una determinata somma di Bitcoin ad un certo prezzo. All'interno della Bid si troveranno le WiretransferInfo che dovranno essere usate dal client per effettuare il pagamento. Infine si dovr\u00e0 utilizzare la seconda operazione verso Conio per comunicare l'avvenuto pagamento della Bid allegando anche una BidCryptoRequest , generata client side, per testimoniare la legittimit\u00e0 dell'operazione.","title":"Acquisto di Bitcoin"},{"location":"exchange/Exchange/#creazione-della-bid","text":"Una Bid si crea specificando la valuta che si intende utilizzare per la transazione e l'importo, o in satoshi o in valuta corrente. Ad esempio, sar\u00e0 quindi possibile richiedere una Bid per l'acquisto di 150\u20ac di Bitcoin o una Bid per l'acquisto di 100.000.000 satoshi. Una volta inviata la richiesta, si otterr\u00e0 una CreatedBid contenente, tra le altre informazioni un bidId . Con questo identificativo sar\u00e0 possibile aggiornare la richiesta di Bid per rimandarne la scadenza e per ottenere le informazioni sul tasso di cambio pi\u00f9 aggiornate. Questo scenario \u00e8 utile nei casi in cui tra la richiesta della Bid e l'effettiva azione dell'utente passi del tempo che renderebbe il tasso di cambio obsoleto.","title":"Creazione della Bid"},{"location":"exchange/Exchange/#metodo_5","text":"exchangeService.createOrRefreshBid","title":"Metodo"},{"location":"exchange/Exchange/#parametri_4","text":"Un oggetto di tipo CreateOrRefreshBidParams , costruibile tramite i metodi factory CreateOrRefreshBidParams.fromFiat o CreateOrRefreshBidParams.fromCrypto che richiedono: currency : di tipo Currency , la valuta dell'operazione; amount : di tipo long per .fromCrypto o Decimal (iOS) / BigDecimal (Android) per .fromFiat , l'ammontare, a seconda del metodo usato, in satoshi o nella valuta scelta che si vuole acquistare; @Opzionale bidId : di tipo String , l'id della bid, da valorizzare solo in caso di refresh della bid stessa.","title":"Parametri"},{"location":"exchange/Exchange/#risposta_5","text":"Un oggetto di tipo CreatedBid che contiene: id : di tipo String , l'id utile al refresh o alla finalizzazione della bid; currency : di tipo Currency , la valuta dell'operazione; cryptoAmount : di tipo long , l'ammontare in satoshi della richiesta d'acquisto; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto al netto delle commissioni; grossFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto comprensivo delle commissioni; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni di servizio per la transazione, espresse nella currency di riferimento expiration : di tipo long , il timestamp di scadenza della richiesta di pagamento. Se la bid scade sar\u00e0 necessario aggiornarla per proseguire wireTransferInfo : di tipo WireTransferInfo , le informazioni necessarie per procedere al pagamento della Bid tramite bonifico.","title":"Risposta"},{"location":"exchange/Exchange/#codice_5","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_5","text":"// Example 1: \u20ac200 bid CreateOrRefreshBidParams params = CreateOrRefreshBidParams.fromFiat(Currency.EUR, 20000); // Example 2: 1.000.000.000 satoshi bid CreateOrRefreshBidParams params = CreateOrRefreshBidParams.fromCrypto(Currency.EUR, 1000000000); conio.exchangeService.createOrRefreshBid(params) .asCallback(result -> result.analysis( bid -> { /* Handle CreatedBid */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_3","text":"// Richiesta d'acquisto per 50\u20ac let params = CreateOrRefreshBidParams(currency: .eur, fiatAmount: 50.0) // Richiesta d'acquisto per 1.000.000 satoshi let params = CreateOrRefreshBidParams(currency: .eur, satoshi: 1000000) // Aggiornamento di una richiesta d'acquisto per 100\u20ac let params = CreateOrRefreshBidParams(bidID: \"bididentifier\", currency: .eur, fiatAmount: 100.0) let consumer = conio.exchangeService.createOrRefreshBid(params: params) consumer.asCallback { result in switch result { case .success(let bid): // Handle CreatedBid case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#utilizzo-della-bid-pagamento","text":"Una volta effettuato il pagamento tramite bonifico si dovr\u00e0 usare l'operazione purchase per comunicare a Conio l'avvenuto pagamento. Questa operazione richieder\u00e0 una BidCryptoRequest .","title":"Utilizzo della Bid (pagamento)"},{"location":"exchange/Exchange/#metodo_6","text":"exchangeService.purchase","title":"Metodo"},{"location":"exchange/Exchange/#parametri_5","text":"Un oggetto di tipo PurchaseParams contenente: bidId : d tipo String , l'id della Bid da pagare cryptoRequest : di tipo BidCryptoRequest , configurabile come descritto nell'apposita sezione","title":"Parametri"},{"location":"exchange/Exchange/#risposta_6","text":"Un oggetto di tipo Success , che conferma l'avvenuta operazione.","title":"Risposta"},{"location":"exchange/Exchange/#errori","text":"INVALID_CRYPTO_PROOF La crypto proof non \u00e8 valida INVALID_PAYMENT_METHOD Il metodo di pagamento non \u00e8 valido UNSUPPORTED_PAYMENT_METHOD Il metodo di pagamento non \u00e8 supportato TRADING_LIMITS_EXCEEDED La bid viola i limiti massimi di acquisto dell'utente TRADE_EXPIRED La bid \u00e8 scaduta BID_ALREADY_PAID La bid \u00e8 gi\u00e0 stata pagata BID_NOT_YET_PAID La bid non \u00e8 ancora stata pagata UNRECOVERABLE_BID La bid \u00e8 in errore FIAT_AMOUNT_TOO_LOW L'importo in Fiat \u00e8 inferiore al limite minimo","title":"Errori"},{"location":"exchange/Exchange/#codice_6","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_6","text":"PurchaseParams params = new PurchaseParams(\"bidId\", bidCryptoRequest); conio.exchangeService.purchase(params) .asCallback(result -> result.analysis( success -> { /* Handle Success */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_4","text":"let params = PurchaseParams(bidId: \"bidId\", cryptoRequest: bidCryptoRequest) let consumer = conio.exchangeService.purchase(params: params) consumer.asCallback { result in switch result { case .success: // Handle Success case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#vendita-di-bitcoin","text":"Per poter vendere dei Bitcoin \u00e8 necessario effettuare due operazioni. La prima \u00e8 quella di creazione di una Ask , ovvero di una richiesta di vendita di una determinata somma di Bitcoin ad un certo prezzo. Si procede poi con il pagamento di tale Ask , passando l' askId e allegando anche una AskCryptoRequest , generata client side, per testimoniare la legittimit\u00e0 dell'operazione. L'SDK firmer\u00e0 la transazione che sposter\u00e0 i Bitcoin dal wallet dell'utente, restituendo alla fine l'id della Ask completata.","title":"Vendita di Bitcoin"},{"location":"exchange/Exchange/#creazione-della-ask","text":"Per richiedere una Ask si dovr\u00e0 procedere analogamente a quanto visto per la Bid. Sar\u00e0 quindi possibile richiedere una CreatedAsk per la vendita di 150\u20ac o una per la vendita di 100.000.000 satoshi. Una volta inviata la richiesta, si otterr\u00e0 una CreatedAsk contenente, tra le altre informazioni un askId . Con questo identificativo sar\u00e0 possibile aggiornare la richiesta di Ask per rimandarne la scadenza e per ottenere le informazioni sul tasso di cambio pi\u00f9 aggiornate. Questo scenario \u00e8 utile nei casi in cui tra la richiesta della Ask e l'effettiva azione dell'utente passi del tempo che renderebbe il tasso di cambio obsoleto.","title":"Creazione della Ask"},{"location":"exchange/Exchange/#metodo_7","text":"exchangeService.createOrRefreshAsk","title":"Metodo"},{"location":"exchange/Exchange/#parametri_6","text":"Un oggetto di tipo CreateOrRefreshAskParams , costruibile tramite i metodi factory CreateOrRefreshAskParams.fromFiat o CreateOrRefreshAskParams.fromCrypto che richiedono: currency : di tipo Currency , la valuta dell'operazione; amount : di tipo long per .fromCrypto o Decimal (iOS) / BigDecimal (Android) per .fromFiat , l'ammontare, a seconda del metodo usato, in satoshi o nella valuta scelta che si vuole vendere; @Opzionale askId : di tipo String , l'id della ask, da valorizzare solo in caso di refresh della ask stessa.","title":"Parametri"},{"location":"exchange/Exchange/#risposta_7","text":"Un oggetto di tipo CreatedAsk che contiene: askId : di tipo String , l'id utile al refresh o alla finalizzazione della ask; currency : di tipo Currency , la valuta dell'operazione; cryptoAmount : di tipo long , l'ammontare in satoshi della richiesta d'acquisto fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni di servizio per la transazione, espresse nella currency di riferimento; miningFee : di tipo long , le commissioni per scrivere la transazione in blockchain, espresse in satoshi; expiration : di tipo long , lo Unix Timestamp di scadenza della richiesta di pagamento. Se la bid scade sar\u00e0 necessario aggiornarla per proseguire","title":"Risposta"},{"location":"exchange/Exchange/#errori_1","text":"TRADING_LIMITS_EXCEEDED L'utente ha 0 Eur di limiti residui NOT_ENOUGH_BTC_AMOUNT solo se non ha btc L'utente non ha alcun bitcoin NO_SUCH_SELLER Errore interno del sottosistema di vendita NO_SUCH_WALLET Errore interno del sottosistema di wallet","title":"Errori"},{"location":"exchange/Exchange/#android_7","text":"// Example 1: \u20ac200 ask CreateOrRefreshAskParams params = CreateOrRefreshAskParams.fromFiat(Currency.EUR, BigDecimal(\"200\")); // Example 2: 1.000.000.000 satoshi ask CreateOrRefreshAskParams params = CreateOrRefreshAskParams.fromCrypto(Currency.EUR, 1000000000); conio.exchangeService.createOrRefreshAsk(params) .asCallback(result -> result.analysis( ask -> { /* Handle CreatedAsk */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_5","text":"// Richiesta di vendita per 50\u20ac let params = CreateOrRefreshAskParams(currency: .eur, fiatAmount: 50.0) // Richiesta di vendita per 100000000 satoshi let params = CreateOrRefreshAskParams(currency: .eur, satoshi: 100000000) // Aggiornamento del valore di una Ask esistente let params = CreateOrRefreshAskParams(askID: \"id\", currency: .eur, fiatAmount: 100.0) conio.exchangeService.createOrRefreshAsk(params: params).asCallback { result in switch result { case .success(let createdAsk): // CreatedBid case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#utilizzo-della-ask","text":"Ottenuta la Ask da utilizzare \u00e8 possibile procedere con la finalizzazione della vendita. Per effettuare questa operazione bisogner\u00e0 passare l'ID della CreatedAsk alla Sell operation, insieme alla AskCryptoRequest .","title":"Utilizzo della Ask"},{"location":"exchange/Exchange/#metodo_8","text":"exchangeService.sell","title":"Metodo"},{"location":"exchange/Exchange/#parametri_7","text":"Un oggetto di tipo SellParams contenente: askId : di tipo String , l'id della Ask cryptoRequest : di tipo AskCryptoRequest , configurabile come descritto nell'apposita sezione","title":"Parametri"},{"location":"exchange/Exchange/#risposta_8","text":"Un oggetto di tipo Success che conferma l'avvenuta operazione.","title":"Risposta"},{"location":"exchange/Exchange/#errori_2","text":"TRADING_LIMITS_EXCEEDED La ask viola i limiti massimi di acquisto dell'utente TRADE_EXPIRED La ask \u00e8 scaduta UNRECOVERABLE_ASK La ask \u00e8 in errore ASK_ALREADY_PAID La ask \u00e8 gi\u00e0 stata pagata NOT_ENOUGH_BTC_AMOUNT_E Bitcoin disponibili non sufficienti DUST_ASK Importo in Bitcoin troppo piccolo FIAT_AMOUNT_TOO_LOW Importo in Eur troppo basso","title":"Errori"},{"location":"exchange/Exchange/#codice_7","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_8","text":"SellParams params = new SellParams(\"askId\", askCryptoRequest); conio.exchangeService.sell(params) .asCallback(result -> result.analysis( success -> { /* Handle Success */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_6","text":"let params = SellParams(askID: askID) conio.exchangeService.createOrRefreshAsk(params: params).asCallback { result in switch result { case .success: // Handle Succes case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"installation/Android/","text":"Installazione su Android L'SDK si installa utilizzando il repository Maven di Artifactory. Per potersi autenticare al repository \u00e8 necessario configurare le credenziali nel file gradle.properties come segue: gradle.properties artifactory_user={username} artifactory_password={password} A questo punto sar\u00e0 possibile aggiungere l'indirizzo del repository nel build.gradle dell'applicazione: app/build.gradle repositories { ... maven { url \"https://artifactory.conio.com/artifactory/gradle-release-local\" credentials(PasswordCredentials) { username \"${artifactory_user}\" password \"${artifactory_password}\" } } } Dopo aver specificato l'indirizzo del repository dal quale verranno sincronizzati gli artefatti sar\u00e0 possibile aggiungere il Conio SDK come dipendeza dell'applicazione: app/build.gradle dependencies { ... implementation 'com.conio:sdk2:[VERSION]' } Sincronizzando il progetto con Gradle sar\u00e0 possibile utilizzare l'SDK.","title":"Android"},{"location":"installation/Android/#installazione-su-android","text":"L'SDK si installa utilizzando il repository Maven di Artifactory. Per potersi autenticare al repository \u00e8 necessario configurare le credenziali nel file gradle.properties come segue:","title":"Installazione su Android"},{"location":"installation/Android/#gradleproperties","text":"artifactory_user={username} artifactory_password={password} A questo punto sar\u00e0 possibile aggiungere l'indirizzo del repository nel build.gradle dell'applicazione:","title":"gradle.properties"},{"location":"installation/Android/#appbuildgradle","text":"repositories { ... maven { url \"https://artifactory.conio.com/artifactory/gradle-release-local\" credentials(PasswordCredentials) { username \"${artifactory_user}\" password \"${artifactory_password}\" } } } Dopo aver specificato l'indirizzo del repository dal quale verranno sincronizzati gli artefatti sar\u00e0 possibile aggiungere il Conio SDK come dipendeza dell'applicazione:","title":"app/build.gradle"},{"location":"installation/Android/#appbuildgradle_1","text":"dependencies { ... implementation 'com.conio:sdk2:[VERSION]' } Sincronizzando il progetto con Gradle sar\u00e0 possibile utilizzare l'SDK.","title":"app/build.gradle"},{"location":"installation/iOS/","text":"Installazione Prerequisiti SDK supporta iOS 10+ Autoconf installato Automake installato Installazione con Cocoapods L'SDK Conio \u00e8 disponibile come Pod ed \u00e8 possibile includerla nei progetti aggiungendo le seguenti righe al Podfile: # The ConioSDK Core pod 'ConioSDK', :git => 'git@bitbucket.org:squadrone/conio-swift-sdk.git', :branch => 'master' # BitcoinKit for encryption purposes pod 'BitcoinKit', :git => 'https://github.com/Conio/BitcoinKit.git', :branch => 'keyconvert' Eseguire il comando pod install nella cartella per ottenere l'SDK. --- Possibili Errori nell'installazione Se si dovesse verificare il seguente messaggio di errore: autoreconf: failed to run aclocal: No such file or directory Eseguire il comando: brew install autoconf && brew install automake . Se si dovesse verificare il seguente messaggio di errore: Can't exec \"/opt/local/bin/aclocal\": No such file or directory Disinstallare dal sistema MacPorts eseguendo: sudo port -fp uninstall --follow-dependents installed","title":"iOS"},{"location":"installation/iOS/#installazione","text":"","title":"Installazione"},{"location":"installation/iOS/#prerequisiti","text":"SDK supporta iOS 10+ Autoconf installato Automake installato","title":"Prerequisiti"},{"location":"installation/iOS/#installazione-con-cocoapods","text":"L'SDK Conio \u00e8 disponibile come Pod ed \u00e8 possibile includerla nei progetti aggiungendo le seguenti righe al Podfile: # The ConioSDK Core pod 'ConioSDK', :git => 'git@bitbucket.org:squadrone/conio-swift-sdk.git', :branch => 'master' # BitcoinKit for encryption purposes pod 'BitcoinKit', :git => 'https://github.com/Conio/BitcoinKit.git', :branch => 'keyconvert' Eseguire il comando pod install nella cartella per ottenere l'SDK.","title":"Installazione con Cocoapods"},{"location":"installation/iOS/#-","text":"","title":"---"},{"location":"installation/iOS/#possibili-errori-nellinstallazione","text":"Se si dovesse verificare il seguente messaggio di errore: autoreconf: failed to run aclocal: No such file or directory Eseguire il comando: brew install autoconf && brew install automake . Se si dovesse verificare il seguente messaggio di errore: Can't exec \"/opt/local/bin/aclocal\": No such file or directory Disinstallare dal sistema MacPorts eseguendo: sudo port -fp uninstall --follow-dependents installed","title":"Possibili Errori nell'installazione"},{"location":"operation/CryptoRequest/","text":"Crypto Request Alcune funzionalit\u00e0 del SDK Conio sono protette da un meccanismo chiamato Crypto Request , che aggiunge un livello di sicurezza ulteriore all'invio di alcuni parametri, tramite una firma crittografica. Le richieste che sfruttano questo meccanismo sono riconoscibili dalla presenza della propriet\u00e0 cryptoRequest , di tipo [Name]CryptoRequest , presente nella funzione di costruzione (costruttore o metodo factory) del oggetto da passare come parametro all'operazione. In particolare, le funzionalit\u00e0 protette da questo meccanismo sono: userService.signup , registrazione dell'utente ( SignupCryptoRequest ); userService.login , autenticazione dell'utente ( LoginCryptoRequest ); exchangeService.purchase , acquisto di Bitcoin ( BidCryptoRequest ); exchangeService.sell , vendita di Bitcoin ( AskCryptoRequest ). La costruzione di ogni propriet\u00e0 di tipo [Name]CryptoRequest necessita di un parametro cryptoProof , un array di byte , ottenuto tramite firma RSA del hash SHA256 della concatenazione (con separatore \"|\") ordinata delle altre propriet\u00e0 del tipo [Name]CryptoRequest (come descritto per ogni tipo [Name]CryptoRequest nel apposito paragrafo). NFC=<implementazione algoritmo di conversione stringa - array di byte> SHA256=<implementazione algoritmo di hashing SHA256> RSA_SIGN=<implementazione algoritmo di firma RSA> CRYPTO_PROOF = RSA_SIGN(SHA256(NFC(DATA_TO_SIGN))) Creazione SignupCryptoRequest Propriet\u00e0 proofID : di tipo String , identificativo della Crypto Request; userID : di tipo String , identificativo esterno del utente; userLevel : di tipo String , livello del utente che ne stabilisce i limiti di compravendita; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; @Opzionale iban : di tipo String , iban del conto bancario associato all'utente, utilizzato come metodo di pagamento per le operazioni di vendita; email : di tipo String , email dell'utente; firstName : di tipo String , nome dell'utente; lastName : di tipo String , cognome dell'utente; DATA_TO_SIGN DATA_TO_SIGN=\"<proofID>|SIGNUP|<userID>|<userLevel>|<proofExpiration>|<email>|<firstName>|<lastName>\" or DATA_TO_SIGN=\"<proofID>|SIGNUP|<userID>|<userLevel>|<proofExpiration>|<iban>|<email>|<firstName>|<lastName>\" Nota : il campo iban \u00e8 opzionale, pertanto, se non lo si inserisce nella SignupCryptoReqeust , va rimosso anche dalla stringa DATA_TO_SIGN (insieme al separatore \"|\") Creazione LoginCryptoRequest Propriet\u00e0 userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; DATA_TO_SIGN DATA_TO_SIGN=\"<userID>|LOGIN|<proofExpiration>\" Creazione AskCryptoRequest Propriet\u00e0 proofID : di tipo String , identificativo della Crypto Request; askID : di tipo String , identificativo della CreatedAsk che si vuole finalizzare; userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; DATA_TO_SIGN DATA_TO_SIGN=\"<proofID>|PAY_FOR_ASK|<askID>|<userID>|<proofExpiration>\" Creazione BidCryptoRequest Propriet\u00e0 proofID : di tipo String , identificativo della Crypto Request; bidID : di tipo String , identificativo dell CreatedBid che si vuole finalizzare; userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; DATA_TO_SIGN DATA_TO_SIGN=\"<proofID>|PAY_FOR_BID_WT|<bidID>|<userID>|<proofExpiration>\"","title":"Crypto Request"},{"location":"operation/CryptoRequest/#crypto-request","text":"Alcune funzionalit\u00e0 del SDK Conio sono protette da un meccanismo chiamato Crypto Request , che aggiunge un livello di sicurezza ulteriore all'invio di alcuni parametri, tramite una firma crittografica. Le richieste che sfruttano questo meccanismo sono riconoscibili dalla presenza della propriet\u00e0 cryptoRequest , di tipo [Name]CryptoRequest , presente nella funzione di costruzione (costruttore o metodo factory) del oggetto da passare come parametro all'operazione. In particolare, le funzionalit\u00e0 protette da questo meccanismo sono: userService.signup , registrazione dell'utente ( SignupCryptoRequest ); userService.login , autenticazione dell'utente ( LoginCryptoRequest ); exchangeService.purchase , acquisto di Bitcoin ( BidCryptoRequest ); exchangeService.sell , vendita di Bitcoin ( AskCryptoRequest ). La costruzione di ogni propriet\u00e0 di tipo [Name]CryptoRequest necessita di un parametro cryptoProof , un array di byte , ottenuto tramite firma RSA del hash SHA256 della concatenazione (con separatore \"|\") ordinata delle altre propriet\u00e0 del tipo [Name]CryptoRequest (come descritto per ogni tipo [Name]CryptoRequest nel apposito paragrafo). NFC=<implementazione algoritmo di conversione stringa - array di byte> SHA256=<implementazione algoritmo di hashing SHA256> RSA_SIGN=<implementazione algoritmo di firma RSA> CRYPTO_PROOF = RSA_SIGN(SHA256(NFC(DATA_TO_SIGN)))","title":"Crypto Request"},{"location":"operation/CryptoRequest/#creazione-signupcryptorequest","text":"","title":"Creazione SignupCryptoRequest"},{"location":"operation/CryptoRequest/#proprieta","text":"proofID : di tipo String , identificativo della Crypto Request; userID : di tipo String , identificativo esterno del utente; userLevel : di tipo String , livello del utente che ne stabilisce i limiti di compravendita; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; @Opzionale iban : di tipo String , iban del conto bancario associato all'utente, utilizzato come metodo di pagamento per le operazioni di vendita; email : di tipo String , email dell'utente; firstName : di tipo String , nome dell'utente; lastName : di tipo String , cognome dell'utente;","title":"Propriet\u00e0"},{"location":"operation/CryptoRequest/#data_to_sign","text":"DATA_TO_SIGN=\"<proofID>|SIGNUP|<userID>|<userLevel>|<proofExpiration>|<email>|<firstName>|<lastName>\" or DATA_TO_SIGN=\"<proofID>|SIGNUP|<userID>|<userLevel>|<proofExpiration>|<iban>|<email>|<firstName>|<lastName>\" Nota : il campo iban \u00e8 opzionale, pertanto, se non lo si inserisce nella SignupCryptoReqeust , va rimosso anche dalla stringa DATA_TO_SIGN (insieme al separatore \"|\")","title":"DATA_TO_SIGN"},{"location":"operation/CryptoRequest/#creazione-logincryptorequest","text":"","title":"Creazione LoginCryptoRequest"},{"location":"operation/CryptoRequest/#proprieta_1","text":"userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida;","title":"Propriet\u00e0"},{"location":"operation/CryptoRequest/#data_to_sign_1","text":"DATA_TO_SIGN=\"<userID>|LOGIN|<proofExpiration>\"","title":"DATA_TO_SIGN"},{"location":"operation/CryptoRequest/#creazione-askcryptorequest","text":"","title":"Creazione AskCryptoRequest"},{"location":"operation/CryptoRequest/#proprieta_2","text":"proofID : di tipo String , identificativo della Crypto Request; askID : di tipo String , identificativo della CreatedAsk che si vuole finalizzare; userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida;","title":"Propriet\u00e0"},{"location":"operation/CryptoRequest/#data_to_sign_2","text":"DATA_TO_SIGN=\"<proofID>|PAY_FOR_ASK|<askID>|<userID>|<proofExpiration>\"","title":"DATA_TO_SIGN"},{"location":"operation/CryptoRequest/#creazione-bidcryptorequest","text":"","title":"Creazione BidCryptoRequest"},{"location":"operation/CryptoRequest/#proprieta_3","text":"proofID : di tipo String , identificativo della Crypto Request; bidID : di tipo String , identificativo dell CreatedBid che si vuole finalizzare; userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida;","title":"Propriet\u00e0"},{"location":"operation/CryptoRequest/#data_to_sign_3","text":"DATA_TO_SIGN=\"<proofID>|PAY_FOR_BID_WT|<bidID>|<userID>|<proofExpiration>\"","title":"DATA_TO_SIGN"},{"location":"operation/Operation/","text":"Operazioni Introduzione Una volta inizializzato l'oggetto Conio , i servizi offerti dal SDK sono raggruppati in 3 categorie: Servizi dell'utente ( conio.userService.* ); Servizi del wallet ( conio.walletService.* ); Servizi di mercato ( conio.exchangeService.* ). Ogni servizio \u00e8 un metodo il cui valore di ritorno \u00e8 un implementazione dell'interfaccia ServiceConsumer<O> . ServiceConsumer L'interfaccia ServiceConsumer<O> (generica in O , il tipo che rappresenta il risultato del servizio stesso) dichiara le modalit\u00e0 con cui i risultati dei servizi possono essere fruiti, infatti espone i metodi: asCallbeck , che richiede come parametro una callback che verr\u00e0 invocata con il risultato del servizio; (Android) asFlow , che restituisce un oggetto di tipo Flow , pi\u00f9 adatto al paradigma di programmazione reattiva; (iOS) asPublisher , TODO. Code Android (Java) conio.walletService.currentBitcoinAddress().asCallback(result -> result.analysis( address -> { /* ... */ }, error -> { /* ... */ } )); Android (Kotlin) runBlocking { conio.walletService.currentBitcoinAddress().asFlow().first().analysis( { address -> /* ... */ }, { error -> /* ... */ } ) } Eccezioni possibili ConioError Questo errore raggruppa tutte le possibili risposte di errore direttamente legate alle operazioni. Lista dei possibili ConioError: APP_IMPROVEMENT_ACCEPTANCE_NOT_ACCEPTED ASK_ALREADY_PAID BID_ALREADY_PAID BID_EXPIRED BID_IS_IN_ERROR BID_NOT_YET_PAID BITHUSTLER_SERVICE_COULD_NOT_CREATE_SELLER CARDS_LIMITS_EXCEEDED CARDS_SERVICE_COULD_NOT_CREATE_PAYER CLIENT_SUPPORT_ACCEPTANCE_NOT_ACCEPTED CRYPTO_PROOF_EXPIRED DUPLICATE_EMAIL_ADDRESS DUST_ASK DUST_TRANSACTION FIAT_AMOUNT_TOO_LOW INCONSISTENT_STATE INCONSISTENT_TRANSACTION INVALID_CRYPTO_PROOF INVALID_IBAN INVALID_MESSAGE_SIGNATURE INVALID_PAYMENT_METHOD INVALID_TOKEN INVALID_TOKEN_PAYLOAD MULTIPLE_SELL_METHODS NO_SUCH3D_SECURE NO_SUCH_SELL_METHOD NO_SUCH_SELLER NO_SUCH_WALLET NO_SUCH_WITHDRAWAL_FEES_INFO NOT_ENOUGH_BTC_AMOUNT TRADE_EXPIRED TRADING_LIMITS_EXCEEDED UNAVAILABLE_BTC_SUBSYSTEM UNRECOVERABLE_ASK UNRECOVERABLE_BID UNSUPPORTED_PAYMENT_METHOD WALLET_ALREADY_CREATED_WITH_DIFFERENT_KEYS WALLET_ALREADY_OWNED_BY_ANOTHER_USER Ad esempio, prendiamo l'operazione conio.walletService.withdrawalFees : se un utente ha 1 bitcoin nel portafoglio e richiede le mining fees per un invio da 50 bitcoin, ricever\u00e0 un NO_SUCH_WITHDRAWAL_FEES_INFO . Code Android WithdrawalFeesParams params = new WithdrawalFeesParams( \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 100000000, TransactionSpeedType.SPEED_FIVE ); conio.walletService.withdrawalFees(params).asCallback(result -> result.analysis( fees -> { /* ... */ }, error -> { ConioException conioException = (ConioException) error; if (conioException.getConioError() == ConioError.NO_SUCH_WITHDRAWAL_FEES_INFO) { /* Handle NO_SUCH_WITHDRAWAL_FEES_INFO error */ } } )); Non autorizzato Questo errore viene generato quando non si \u00e8 autorizzati a utilizzare un metodo per uno dei seguenti motivi: utilizzo di un metodo che richiede autenticazione senza una sessione valida; si sta provando ad effettura una login con credenziali errate. Assicurarsi di avere una sessione valida, autenticandosi nuovamente tramite una login o una sign-up . Codice Android UserLogin user = new UserLogin(\"username\", \"wrong_password\"); conio.userService.login(user).asCallback(result -> result.analysis( success -> { /* ... */ }, error -> { if (error instanceof UnauthorizedException) { /* Handle the error */ } // Or ServiceException serviceException = (ServiceException) error; if (serviceException.getServiceError() == ServiceError.UNAUTHORIZED) { /* Handle the error */ } } )); SDK obsoleto Questo errore viene generato quando l'utente tenta di utilizzare una versione obsoleta dell'SDK. Consigliamo di gestire questo errore per notificare all'utente di aggiornare l'applicazione. Code Android LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params).asCallback(result -> result.analysis( acceptances -> { /* ... */ }, error -> { if (error instanceof OutdatedSDKException) { /* Handle the error */ } // Or ServiceException serviceException = (ServiceException) error; if (serviceException.getServiceError() == ServiceError.OUTDATED_SDK) { /* Handle the error */ } } )); iOS let params = LegalAcceptancesParams(language: .italian) conio.userService.getLegalAcceptances(params: params).asCallback { result in switch result { case .success: // success case .failure(let error): if case .outdatedSDK = error { print(\"Please update the SDK\") } } }","title":"Generale"},{"location":"operation/Operation/#operazioni","text":"","title":"Operazioni"},{"location":"operation/Operation/#introduzione","text":"Una volta inizializzato l'oggetto Conio , i servizi offerti dal SDK sono raggruppati in 3 categorie: Servizi dell'utente ( conio.userService.* ); Servizi del wallet ( conio.walletService.* ); Servizi di mercato ( conio.exchangeService.* ). Ogni servizio \u00e8 un metodo il cui valore di ritorno \u00e8 un implementazione dell'interfaccia ServiceConsumer<O> .","title":"Introduzione"},{"location":"operation/Operation/#serviceconsumer","text":"L'interfaccia ServiceConsumer<O> (generica in O , il tipo che rappresenta il risultato del servizio stesso) dichiara le modalit\u00e0 con cui i risultati dei servizi possono essere fruiti, infatti espone i metodi: asCallbeck , che richiede come parametro una callback che verr\u00e0 invocata con il risultato del servizio; (Android) asFlow , che restituisce un oggetto di tipo Flow , pi\u00f9 adatto al paradigma di programmazione reattiva; (iOS) asPublisher , TODO.","title":"ServiceConsumer"},{"location":"operation/Operation/#code","text":"","title":"Code"},{"location":"operation/Operation/#android-java","text":"conio.walletService.currentBitcoinAddress().asCallback(result -> result.analysis( address -> { /* ... */ }, error -> { /* ... */ } ));","title":"Android (Java)"},{"location":"operation/Operation/#android-kotlin","text":"runBlocking { conio.walletService.currentBitcoinAddress().asFlow().first().analysis( { address -> /* ... */ }, { error -> /* ... */ } ) }","title":"Android (Kotlin)"},{"location":"operation/Operation/#eccezioni-possibili","text":"","title":"Eccezioni possibili"},{"location":"operation/Operation/#conioerror","text":"Questo errore raggruppa tutte le possibili risposte di errore direttamente legate alle operazioni. Lista dei possibili ConioError: APP_IMPROVEMENT_ACCEPTANCE_NOT_ACCEPTED ASK_ALREADY_PAID BID_ALREADY_PAID BID_EXPIRED BID_IS_IN_ERROR BID_NOT_YET_PAID BITHUSTLER_SERVICE_COULD_NOT_CREATE_SELLER CARDS_LIMITS_EXCEEDED CARDS_SERVICE_COULD_NOT_CREATE_PAYER CLIENT_SUPPORT_ACCEPTANCE_NOT_ACCEPTED CRYPTO_PROOF_EXPIRED DUPLICATE_EMAIL_ADDRESS DUST_ASK DUST_TRANSACTION FIAT_AMOUNT_TOO_LOW INCONSISTENT_STATE INCONSISTENT_TRANSACTION INVALID_CRYPTO_PROOF INVALID_IBAN INVALID_MESSAGE_SIGNATURE INVALID_PAYMENT_METHOD INVALID_TOKEN INVALID_TOKEN_PAYLOAD MULTIPLE_SELL_METHODS NO_SUCH3D_SECURE NO_SUCH_SELL_METHOD NO_SUCH_SELLER NO_SUCH_WALLET NO_SUCH_WITHDRAWAL_FEES_INFO NOT_ENOUGH_BTC_AMOUNT TRADE_EXPIRED TRADING_LIMITS_EXCEEDED UNAVAILABLE_BTC_SUBSYSTEM UNRECOVERABLE_ASK UNRECOVERABLE_BID UNSUPPORTED_PAYMENT_METHOD WALLET_ALREADY_CREATED_WITH_DIFFERENT_KEYS WALLET_ALREADY_OWNED_BY_ANOTHER_USER Ad esempio, prendiamo l'operazione conio.walletService.withdrawalFees : se un utente ha 1 bitcoin nel portafoglio e richiede le mining fees per un invio da 50 bitcoin, ricever\u00e0 un NO_SUCH_WITHDRAWAL_FEES_INFO .","title":"ConioError"},{"location":"operation/Operation/#code_1","text":"","title":"Code"},{"location":"operation/Operation/#android","text":"WithdrawalFeesParams params = new WithdrawalFeesParams( \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 100000000, TransactionSpeedType.SPEED_FIVE ); conio.walletService.withdrawalFees(params).asCallback(result -> result.analysis( fees -> { /* ... */ }, error -> { ConioException conioException = (ConioException) error; if (conioException.getConioError() == ConioError.NO_SUCH_WITHDRAWAL_FEES_INFO) { /* Handle NO_SUCH_WITHDRAWAL_FEES_INFO error */ } } ));","title":"Android"},{"location":"operation/Operation/#non-autorizzato","text":"Questo errore viene generato quando non si \u00e8 autorizzati a utilizzare un metodo per uno dei seguenti motivi: utilizzo di un metodo che richiede autenticazione senza una sessione valida; si sta provando ad effettura una login con credenziali errate. Assicurarsi di avere una sessione valida, autenticandosi nuovamente tramite una login o una sign-up .","title":"Non autorizzato"},{"location":"operation/Operation/#codice","text":"","title":"Codice"},{"location":"operation/Operation/#android_1","text":"UserLogin user = new UserLogin(\"username\", \"wrong_password\"); conio.userService.login(user).asCallback(result -> result.analysis( success -> { /* ... */ }, error -> { if (error instanceof UnauthorizedException) { /* Handle the error */ } // Or ServiceException serviceException = (ServiceException) error; if (serviceException.getServiceError() == ServiceError.UNAUTHORIZED) { /* Handle the error */ } } ));","title":"Android"},{"location":"operation/Operation/#sdk-obsoleto","text":"Questo errore viene generato quando l'utente tenta di utilizzare una versione obsoleta dell'SDK. Consigliamo di gestire questo errore per notificare all'utente di aggiornare l'applicazione.","title":"SDK obsoleto"},{"location":"operation/Operation/#code_2","text":"","title":"Code"},{"location":"operation/Operation/#android_2","text":"LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params).asCallback(result -> result.analysis( acceptances -> { /* ... */ }, error -> { if (error instanceof OutdatedSDKException) { /* Handle the error */ } // Or ServiceException serviceException = (ServiceException) error; if (serviceException.getServiceError() == ServiceError.OUTDATED_SDK) { /* Handle the error */ } } ));","title":"Android"},{"location":"operation/Operation/#ios","text":"let params = LegalAcceptancesParams(language: .italian) conio.userService.getLegalAcceptances(params: params).asCallback { result in switch result { case .success: // success case .failure(let error): if case .outdatedSDK = error { print(\"Please update the SDK\") } } }","title":"iOS"},{"location":"user/User/","text":"Operazioni sull'utente Recupero dei termini di servizio Questa operazione consente di recuperare le LegalAcceptances , ovvero le condizioni che l'utente potr\u00e0/dovr\u00e0 accettare in fase di signup (scelte che, durante l' operazione signup , dovranno essere descritte tramite la classe Acceptances ). L'oggetto LegalAcceptances recuperato conterr\u00e0 gli url per mostrare le pagine dei Termini di Servizio e Privacy Policies di Conio e il dettaglio delle acceptances ( AcceptanceDetail ) che l'utente dovr\u00e0 o meno accettare. Metodo userService.getLegalAcceptances Parametri Un oggetto di tipo LegalAcceptancesParams contenente la lingua di riferimento per ottenere le acceptances e gli url delle pagine web da mostrare all'utente. Risposta Un oggetto di tipo LegalAcceptances contenente la lista degli AcceptanceDetail , lo url dei Termini di Servizio e quello delle Privacy Policies . Codice Android LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params) .asCallback(result -> result.analysis( acceptances -> { /* Handle LegalAcceptances */ }, error -> { /* Handle error */ } )); iOS let params = LegalAcceptancesParams(language: .italian) conio.userService.signup(params: params).asCallback { result in switch result { case .success(let acceptances): // LegalAcceptances case .failure(let error): // Operation Error } } Autenticazione Per poter operare con il portafoglio Conio occorre essere autenticati. Se \u00e8 la prima volta che l'utente usa il servizio ci si pu\u00f2 autenticare con il metodo userService.signup , altrimenti con il metodo userService.login . Signup L'operazione di signup permette di creare un nuovo utente Conio. Metodo userService.signup Parametri Un oggetto di tipo SignupParams , costruito tramite il metodo SignupParams.createCryptoSignup con: acceptances : di tipo Acceptances con l'esito della conferma ai termini di servizio da parte dell'utente, recuperati tramite le LegalAcceptances ; credentials : di tipo ConioCredentials con username e password dell'utente; cryptoRequest : di tipo SignupCryptoRequest , che specifica ulteriori parametri comprovati da una firma, come descritto in creazione della SignupCryptoRequest . Risposta Un oggetto di tipo Success che indica che l'utente \u00e8 stato autenticato. Errori ConioError : APP_IMPROVEMENT_ACCEPTANCE_NOT_ACCEPTED Acceptance obbligatoria; CLIENT_SUPPORT_ACCEPTANCE_NOT_ACCEPTED Acceptance obbligatoria; CRYPTO_PROOF_EXPIRED La crypto proof \u00e8 scaduta; INVALID_CRYPTO_PROOF La crypto proof non \u00e8 correttamente firmata; DUPLICATE_EMAIL_ADDRESS Indirizzo email duplicato; INVALID_IBAN IBAN non valido; WALLET_ALREADY_OWNED_BY_ANOTHER_USER Il wallet \u00e8 gi\u00e0 utilizzato da un altro utente; CARDS_SERVICE_COULD_NOT_CREATE_PAYER Errore interno del sottosistema di pagamento. Codice Android // vedi \"Creazione SignupCryptoRequest\" SignupCryptoRequest cryptoRequest = new SignupCryptoRequest(...); ConioCredentials credentials = new ConioCredentials(\"username\", \"password\"); Acceptances acceptances = new Acceptances(Arrays.asList( new Acceptance(AcceptanceType.CLIENT_SUPPORT, true), new Acceptance(AcceptanceType.APP_IMPROVEMENT, true) )); SignupParams params = SignupParams.createCryptoSignup(acceptances, credentials, cryptoRequest); conio.userService.signup(params) .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } )); iOS // vedi \"Creazione SignupCryptoRequest\" let credentials = ConioCredentials(username: \"username\", password: \"password\") var acceptancesList = [Acceptance]() acceptancesList.append(.init(type: .appImprovement, isAccepted: true)) acceptancesList.append(.init(type: .clientSupport, isAccepted: true)) let acceptances = Acceptances(acceptances: acceptancesList) let cryptoRequest = SignupCryptoRequest.init(proofID: \"\", cryptoProof: Data(), proofExpiration: 0, externalUserID: \"\", userLevel: \"\", iban: \"\", email: \"\", firstName: \"\", lastName: \"\") let signupParams = SignupParams.createCryptoSignup(credentials: credentials, acceptances: acceptances, cryptoRequest: cryptoRequest) conio.userService.signup(params: params).asCallback { result in switch result { case .success: // Handle Succes case .failure(let error): // Operation Error } } Login L'operazione di login permette di autenticarsi a Conio. \u00c8 raccomandabile eseguire questa operazione ad ogni avvio dell'applicazione, similmente a come avviene per altri servizi terzi. Metodo userService.login Parametri Un oggetto di tipo LoginParams , costruito tramite il metodo LoginParams.createCryptoLogin con: credentials : di tipo ConioCredentials con username e password dell'utente cryptoRequest : di tipo LoginCryptoRequest , che specifica ulteriori parametri comprovati da una firma, come descritto in creazione della LoginCryptoRequest . Risposta Un oggetto di tipo Success che indica che l'utente \u00e8 stato autenticato. Errori Non autorizzato Codice Android LoginCryptoRequest cryptoRequest = new LoginCryptoRequest(...); ConioCredentials credentials = new ConioCredentials(\"username\", \"password\"); LoginParams params = LoginParams.createCryptoLogin(credentials, cryptoRequest); conio.userService.login(params) .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } )); iOS let params = LoginParams(username: \"lemonade\", password: \"secretword\", loginCryptoRequest: <LoginCryptoRequest>) conio.userService.login(params: params).asCallback { result in switch result { case .success: // success case .failure(let error): // Operation Error } } Logout Consente di disconnettere l'utenza Conio. Metodo userService.logout Risposta Un oggetto di tipo Success che indica che l'utente \u00e8 stato disconnesso. Codice Android conio.userService.logout() .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } )); iOS conio.userService.logout().asCallback { result in switch result { case .success: // success case .failure(let error): // Operation Error } }","title":"Utente"},{"location":"user/User/#operazioni-sullutente","text":"","title":"Operazioni sull'utente"},{"location":"user/User/#recupero-dei-termini-di-servizio","text":"Questa operazione consente di recuperare le LegalAcceptances , ovvero le condizioni che l'utente potr\u00e0/dovr\u00e0 accettare in fase di signup (scelte che, durante l' operazione signup , dovranno essere descritte tramite la classe Acceptances ). L'oggetto LegalAcceptances recuperato conterr\u00e0 gli url per mostrare le pagine dei Termini di Servizio e Privacy Policies di Conio e il dettaglio delle acceptances ( AcceptanceDetail ) che l'utente dovr\u00e0 o meno accettare.","title":"Recupero dei termini di servizio"},{"location":"user/User/#metodo","text":"userService.getLegalAcceptances","title":"Metodo"},{"location":"user/User/#parametri","text":"Un oggetto di tipo LegalAcceptancesParams contenente la lingua di riferimento per ottenere le acceptances e gli url delle pagine web da mostrare all'utente.","title":"Parametri"},{"location":"user/User/#risposta","text":"Un oggetto di tipo LegalAcceptances contenente la lista degli AcceptanceDetail , lo url dei Termini di Servizio e quello delle Privacy Policies .","title":"Risposta"},{"location":"user/User/#codice","text":"","title":"Codice"},{"location":"user/User/#android","text":"LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params) .asCallback(result -> result.analysis( acceptances -> { /* Handle LegalAcceptances */ }, error -> { /* Handle error */ } ));","title":"Android"},{"location":"user/User/#ios","text":"let params = LegalAcceptancesParams(language: .italian) conio.userService.signup(params: params).asCallback { result in switch result { case .success(let acceptances): // LegalAcceptances case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"user/User/#autenticazione","text":"Per poter operare con il portafoglio Conio occorre essere autenticati. Se \u00e8 la prima volta che l'utente usa il servizio ci si pu\u00f2 autenticare con il metodo userService.signup , altrimenti con il metodo userService.login .","title":"Autenticazione"},{"location":"user/User/#signup","text":"L'operazione di signup permette di creare un nuovo utente Conio.","title":"Signup"},{"location":"user/User/#metodo_1","text":"userService.signup","title":"Metodo"},{"location":"user/User/#parametri_1","text":"Un oggetto di tipo SignupParams , costruito tramite il metodo SignupParams.createCryptoSignup con: acceptances : di tipo Acceptances con l'esito della conferma ai termini di servizio da parte dell'utente, recuperati tramite le LegalAcceptances ; credentials : di tipo ConioCredentials con username e password dell'utente; cryptoRequest : di tipo SignupCryptoRequest , che specifica ulteriori parametri comprovati da una firma, come descritto in creazione della SignupCryptoRequest .","title":"Parametri"},{"location":"user/User/#risposta_1","text":"Un oggetto di tipo Success che indica che l'utente \u00e8 stato autenticato.","title":"Risposta"},{"location":"user/User/#errori","text":"ConioError : APP_IMPROVEMENT_ACCEPTANCE_NOT_ACCEPTED Acceptance obbligatoria; CLIENT_SUPPORT_ACCEPTANCE_NOT_ACCEPTED Acceptance obbligatoria; CRYPTO_PROOF_EXPIRED La crypto proof \u00e8 scaduta; INVALID_CRYPTO_PROOF La crypto proof non \u00e8 correttamente firmata; DUPLICATE_EMAIL_ADDRESS Indirizzo email duplicato; INVALID_IBAN IBAN non valido; WALLET_ALREADY_OWNED_BY_ANOTHER_USER Il wallet \u00e8 gi\u00e0 utilizzato da un altro utente; CARDS_SERVICE_COULD_NOT_CREATE_PAYER Errore interno del sottosistema di pagamento.","title":"Errori"},{"location":"user/User/#codice_1","text":"","title":"Codice"},{"location":"user/User/#android_1","text":"// vedi \"Creazione SignupCryptoRequest\" SignupCryptoRequest cryptoRequest = new SignupCryptoRequest(...); ConioCredentials credentials = new ConioCredentials(\"username\", \"password\"); Acceptances acceptances = new Acceptances(Arrays.asList( new Acceptance(AcceptanceType.CLIENT_SUPPORT, true), new Acceptance(AcceptanceType.APP_IMPROVEMENT, true) )); SignupParams params = SignupParams.createCryptoSignup(acceptances, credentials, cryptoRequest); conio.userService.signup(params) .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } ));","title":"Android"},{"location":"user/User/#ios_1","text":"// vedi \"Creazione SignupCryptoRequest\" let credentials = ConioCredentials(username: \"username\", password: \"password\") var acceptancesList = [Acceptance]() acceptancesList.append(.init(type: .appImprovement, isAccepted: true)) acceptancesList.append(.init(type: .clientSupport, isAccepted: true)) let acceptances = Acceptances(acceptances: acceptancesList) let cryptoRequest = SignupCryptoRequest.init(proofID: \"\", cryptoProof: Data(), proofExpiration: 0, externalUserID: \"\", userLevel: \"\", iban: \"\", email: \"\", firstName: \"\", lastName: \"\") let signupParams = SignupParams.createCryptoSignup(credentials: credentials, acceptances: acceptances, cryptoRequest: cryptoRequest) conio.userService.signup(params: params).asCallback { result in switch result { case .success: // Handle Succes case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"user/User/#login","text":"L'operazione di login permette di autenticarsi a Conio. \u00c8 raccomandabile eseguire questa operazione ad ogni avvio dell'applicazione, similmente a come avviene per altri servizi terzi.","title":"Login"},{"location":"user/User/#metodo_2","text":"userService.login","title":"Metodo"},{"location":"user/User/#parametri_2","text":"Un oggetto di tipo LoginParams , costruito tramite il metodo LoginParams.createCryptoLogin con: credentials : di tipo ConioCredentials con username e password dell'utente cryptoRequest : di tipo LoginCryptoRequest , che specifica ulteriori parametri comprovati da una firma, come descritto in creazione della LoginCryptoRequest .","title":"Parametri"},{"location":"user/User/#risposta_2","text":"Un oggetto di tipo Success che indica che l'utente \u00e8 stato autenticato.","title":"Risposta"},{"location":"user/User/#errori_1","text":"Non autorizzato","title":"Errori"},{"location":"user/User/#codice_2","text":"","title":"Codice"},{"location":"user/User/#android_2","text":"LoginCryptoRequest cryptoRequest = new LoginCryptoRequest(...); ConioCredentials credentials = new ConioCredentials(\"username\", \"password\"); LoginParams params = LoginParams.createCryptoLogin(credentials, cryptoRequest); conio.userService.login(params) .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } ));","title":"Android"},{"location":"user/User/#ios_2","text":"let params = LoginParams(username: \"lemonade\", password: \"secretword\", loginCryptoRequest: <LoginCryptoRequest>) conio.userService.login(params: params).asCallback { result in switch result { case .success: // success case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"user/User/#logout","text":"Consente di disconnettere l'utenza Conio.","title":"Logout"},{"location":"user/User/#metodo_3","text":"userService.logout","title":"Metodo"},{"location":"user/User/#risposta_3","text":"Un oggetto di tipo Success che indica che l'utente \u00e8 stato disconnesso.","title":"Risposta"},{"location":"user/User/#codice_3","text":"","title":"Codice"},{"location":"user/User/#android_3","text":"conio.userService.logout() .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } ));","title":"Android"},{"location":"user/User/#ios_3","text":"conio.userService.logout().asCallback { result in switch result { case .success: // success case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/","text":"Operazioni sul portafoglio Indirizzo Bitcoin attuale Permette di recuperare l'indirizzo corrente del portafoglio su cui sar\u00e0 possibile ricevere delle transazioni. Metodo walletService.currentBitcoinAddress Risposta Una stringa contenente l'indirizzo Bitcoin attuale. Errori Non autorizzato Codice Android conio.walletService.currentBitcoinAddress() .asCallback(result -> result.analysis( address -> {/* Handle string wallet address */ }, error -> { /* ... */ } )); iOS conio.walletService.currentBitcoinAddress().asCallback { result in switch result { case .success(let address): // Handle string wallet address case .failure(let error): // Operation Error } } Lista movimenti bitcoin Ciascuna operazione di invio, ricezione, acquisto e vendita di Bitcoin \u00e8 rappresentata da un' Activity . La lista delle attivit\u00e0 svolte dall'utente pu\u00f2 essere recuperata tramite l'apposito metodo. Metodo walletService.activityList Parametri Un oggetto di tipo ActivityListParams contenente: types : di tipo List<ActivityType> , una lista di enumerati ActivityType che ci permette di specificare le tipologie di activities da recuperare. Tramite ActivityType.all() \u00e8 possibile ottenere una lista di tutte le tipologie di Activity ; currency : di tipo Currency , la valuta nella quale si vuole conoscere il valore della transazioni di acquisto e vendita (attualmente solo Euro); @Default(6) limit : di tipo intero , il numero massimo di transazioni da ricevere nella risposta; @Opzionale nextPage : di tipo String , token per la paginazione delle activities, ottenibile tramite il risultato di una prima richiesta di lista movimenti con questo valore nullo. Inserendo tale valore \u00e8 possibile ottenere le successive n Activity (con n = valore inserito come limit ); @Opzionale timeFrame : di tipo TimeFrame , la finestra temporale che definisce quali Activity includere nella risposta. Risposta Un oggetto di tipo ActivityList contenente: activities : di tipo List<SimpleActivity> , ovvero la lista delle Activity dell'utente richieste; @Opzionale nextPage : di tipo String , token per la paginazione delle activity, che pu\u00f2 essere inserito in una successiva richiesta di lista movimenti . Quando questo campo \u00e8 nullo, significa che non esistono ulteriori Activity tra quelle che rispettano i filtri inseriti. Ogni Activity resituita (di tipo SimpleActivity ) contiene: activityId : di tipo String , l'identificativo univoco della Activity ; type : di tipo ActivityType , la tipologia di Activity ( SEND , BUY , SELL , RECEIVE ); status : di tipo TransactionStatus , lo stato di conferma della transazione Bitcoin legata all' Activity ( UNCONFIRMED , PARTIALLY_CONFIRMED , CONFIRMED ); createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi. cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi), movimentato dall' Activity ; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il corrispettivo ammontare di cryptoAmount , calcolato nella valuta indicata tramite il campo currency ; Errori Non autorizzato Codice Android // Example 1: retrieve 6 activities of all type List<ActivityType> types = ActivityType.all; ActivityListParams params = new ActivityListParams(types, Currency.EUR); // Example 2: retrieve 10 sell activities List<ActivityType> types = Collections.singletonList(ActivityType.SELL); ActivityListParams params = new ActivityListParams(types, Currency.EUR, 10); // Example 3: retrieve 6 buy and receive activities of the last month List<ActivityType> types = Arrays.asList(ActivityType.BUY, ActivityType.RECEIVE); ActivityListParams params = new ActivityListParams( types, // types Currency.EUR, // currency 6, // limit null, // nextPage TimeFrame.lastMonth() // timeFrame ); conio.walletService.activityList(params) .asCallback(result -> result.analysis( activityList -> { /* Handle ActivityList */ }, error -> { /* ... */ } )); iOS let types = WalletActivityType.allCases let params = ActivitiesParams(nextPage: \"string\", types: types) conio.walletService.walletActivities(params: params).asCallback { result in switch result { case .success(let activities): // WalletActivities case .failure(let error): // Operation Error } } Dettaglio di un movimento Recuperata la lista delle attivit\u00e0 \u00e8 possibile ottenere ulteriori informazioni su un Activity specifica richiedendone il dettaglio. Metodo walletService.activityDetails Parametri Un oggetto di tipo ActivityDetailsParams contenente: activityId : di tipo String , l'id dell' Activity della quale si vuole leggere il dettaglio; currency : di tipo Currency , la valuta nella quale si vuole conoscere il valore della transazioni di acquisto e vendita (attualmente solo Euro); Risposta Un oggetto di tipo ActivityDetails contenente: activityId : di tipo String , l'id dell'attivit\u00e0; type : di tipo ActivityType , la tipologia di Activity ( SEND , BUY , SELL , RECEIVE ); createdAt : di tipo Long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi. @Opzionale transaction : di tipo Transaction , la transazione annessa. Popolato nel caso in cui sia stata effettuata una transazione. Contiene informazioni sulla transazione Bitcoin associata all' Activity , quali: hash : di tipo String , l'hash della transazione Bitcoin; status : di tipo TransactionStatus , lo stato di conferma della transazione Bitcoin legata all' Activity ( UNCONFIRMED , PARTIALLY_CONFIRMED , CONFIRMED ); type : di tipo TransactionType , il tipo di transazione Bitcoin ( GENERIC o REDEPOSIT , ovvero una transazione verso se stessi); addresses : di tipo List<String> , gli indirizzi Bitcoin dei dei mittenti (per le transazioni in entrata) o dei destinatari (per le transazioni in uscita); cryptoAmount : di tipo long miningFees : di tipo long , le commissioni pagate alle rete Bitcoin per processare la transazione; isIncoming : di tipo booleano , flag indicante se la transazione \u00e8 in entrata o in uscita rispetto al portafoglio dell'utente; isLocal : di tipo booleano , flag indicante se la transazione \u00e8 stata ricevuta/inviata da/a un portafoglio Conio. @Opzionale associatedBid : l'offerta di acquisto annessa. Popolato in caso di attivit\u00e0 di acquisto. Contiene le informazioni sulla richiesta di acquisto, quali: status : di tipo BidStatus , lo stato del pagamento della richiesta di acquisto ( PAID , CHARGED ); cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) acquistato; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il controvalore (rispetto al cryptoAmount ) accordato per l'acquisto dei bitcoin, calcolato nella valuta indicata dal campo currency ; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni pagate per la fruizione del servizio, calcolato nella valuta indicata dal campo currency ; currency : di tipo Currency , la valuta usata per l'acquisto dei bitcoin; paymentMethodId : di tipo String , l'identificativo del metodo di pagamento; createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi; paidAt : di tipo long , l'istante temporale in cui \u00e8 stato effettuato il pagamento per l'acquisto dei bitcoin, espresso come Unix Timestamp in millisecondi; @Opzionale chargedAt : di tipo long , l'istante temporale in cui \u00e8 stata invaita la transazione bitcoin, espresso come Unix Timestamp in millisecondi. Nullo nel caso in cui la transazione non sia ancora stata effettuata. @Opzionale associatedAsk : l'offerta di vendita annessa. Popolato in caso di attivit\u00e0 di vendita, Contiene le informazioni sulla richeista di vendita, quali: status : di tipo AskStatus , lo stato del pagamento della richiesta di vendita ( CHARGED , PAID ) cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) venduto; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il controvalore (rispetto al cryptoAmount ) accordato per la vendita dei bitcoin, calcolato nella valuta indicata dal campo currency ; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni pagate per la fruizione del servizio, calcolato nella valuta indicata dal campo currency ; currency : di tipo Currency , la valuta usata per la vendita dei bitcoin; sellMethodId : di tipo String , l'identificativo del metodo di riscossione della vendita; cro : di tipo String , il Codice Riferimento Operazione della transazione bancaria; iban : di tipo String , l'IBAN del richiedente del bonifico bancario; createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi; chargedAt : di tipo long , l'istante temporale in cui \u00e8 stata invaita la transazione bitcoin, espresso come Unix Timestamp in millisecondi; @Opzionale paidAt : di tipo long , l'istante temporale in cui \u00e8 stato effettuato il pagamento per la vendita dei bitcoin, espresso come Unix Timestamp in millisecondi. Nullo nel caso in cui la transazione non sia ancora stata effettuata. Errori Non autorizzato Codice Android ActivityDetailsParams params = new ActivityDetailsParams(\"activityId\", Currency.EUR); conio.walletService.activityDetails(params) .asCallback(result -> result.analysis( details -> { /* Handle ActivityDetails */ }, error -> { /* ... */ } )); iOS let params = ActivityDetailsParams(activityId: \"activityId\", currency: .eur) conio.walletService.activityDetails(params: params).asCallback { result in switch result { case .success(let details): // ActivityDetails case .failure(let error): // Operation Error } } Bilancio del portafoglio Permette di recuperare il bilancio del portafoglio Bitcoin dell'utente. Metodo walletService.walletBalances Risposta Un oggetto di tipo WalletBalances contenente il valore di bitcoin presente nel wallet espresso in satoshi (1 bitcoin = 100.000.000 satoshi). Il valore si divide in: confirmedBalance : di tipo long , valore con almeno 3 conferme sulla blockchain Bitcoin e quindi disponibile per l'utente; unconfirmedBalance : di tipo long , valore con meno di 3 conferme e quindi non ancora disponibile. Errori Non autorizzato Codice Android conio.walletService.walletBalances() .asCallback(result -> result.analysis( balances -> { /* Handle WalletBalances */ }, error -> { /* ... */ } )); iOS conio.walletService.walletBalances().asCallback { result in switch result { case .success(let balances): // WalletBalances case .failure(let error): // Operation Error } } Codice di recupero Bitcoin Permette di recuperare dalla memoria del dispositivo il \"Codie di recupero Bitcoin\": 12 parole di backup del portafoglio Bitcoin. Risposta Un oggetto di tipo MnemonicWords contenente un array di 12 stringhe. Errori Non autorizzato Codice Android conio.walletService.readMnemonic() .asCallback(result -> result.analysis( mnemonic -> { /* Handle MnemonicWords */ }, error -> { /* ... */ } )); iOS conio.walletService.readMnemonic().asCallback { result in switch result { case .success(let mnemonic): // MnemonicWords case .failure(let error): // Operation Error } }","title":"Operazioni sul portafoglio"},{"location":"wallet/Wallet/#operazioni-sul-portafoglio","text":"","title":"Operazioni sul portafoglio"},{"location":"wallet/Wallet/#indirizzo-bitcoin-attuale","text":"Permette di recuperare l'indirizzo corrente del portafoglio su cui sar\u00e0 possibile ricevere delle transazioni.","title":"Indirizzo Bitcoin attuale"},{"location":"wallet/Wallet/#metodo","text":"walletService.currentBitcoinAddress","title":"Metodo"},{"location":"wallet/Wallet/#risposta","text":"Una stringa contenente l'indirizzo Bitcoin attuale.","title":"Risposta"},{"location":"wallet/Wallet/#errori","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice","text":"","title":"Codice"},{"location":"wallet/Wallet/#android","text":"conio.walletService.currentBitcoinAddress() .asCallback(result -> result.analysis( address -> {/* Handle string wallet address */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios","text":"conio.walletService.currentBitcoinAddress().asCallback { result in switch result { case .success(let address): // Handle string wallet address case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/#lista-movimenti-bitcoin","text":"Ciascuna operazione di invio, ricezione, acquisto e vendita di Bitcoin \u00e8 rappresentata da un' Activity . La lista delle attivit\u00e0 svolte dall'utente pu\u00f2 essere recuperata tramite l'apposito metodo.","title":"Lista movimenti bitcoin"},{"location":"wallet/Wallet/#metodo_1","text":"walletService.activityList","title":"Metodo"},{"location":"wallet/Wallet/#parametri","text":"Un oggetto di tipo ActivityListParams contenente: types : di tipo List<ActivityType> , una lista di enumerati ActivityType che ci permette di specificare le tipologie di activities da recuperare. Tramite ActivityType.all() \u00e8 possibile ottenere una lista di tutte le tipologie di Activity ; currency : di tipo Currency , la valuta nella quale si vuole conoscere il valore della transazioni di acquisto e vendita (attualmente solo Euro); @Default(6) limit : di tipo intero , il numero massimo di transazioni da ricevere nella risposta; @Opzionale nextPage : di tipo String , token per la paginazione delle activities, ottenibile tramite il risultato di una prima richiesta di lista movimenti con questo valore nullo. Inserendo tale valore \u00e8 possibile ottenere le successive n Activity (con n = valore inserito come limit ); @Opzionale timeFrame : di tipo TimeFrame , la finestra temporale che definisce quali Activity includere nella risposta.","title":"Parametri"},{"location":"wallet/Wallet/#risposta_1","text":"Un oggetto di tipo ActivityList contenente: activities : di tipo List<SimpleActivity> , ovvero la lista delle Activity dell'utente richieste; @Opzionale nextPage : di tipo String , token per la paginazione delle activity, che pu\u00f2 essere inserito in una successiva richiesta di lista movimenti . Quando questo campo \u00e8 nullo, significa che non esistono ulteriori Activity tra quelle che rispettano i filtri inseriti. Ogni Activity resituita (di tipo SimpleActivity ) contiene: activityId : di tipo String , l'identificativo univoco della Activity ; type : di tipo ActivityType , la tipologia di Activity ( SEND , BUY , SELL , RECEIVE ); status : di tipo TransactionStatus , lo stato di conferma della transazione Bitcoin legata all' Activity ( UNCONFIRMED , PARTIALLY_CONFIRMED , CONFIRMED ); createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi. cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi), movimentato dall' Activity ; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il corrispettivo ammontare di cryptoAmount , calcolato nella valuta indicata tramite il campo currency ;","title":"Risposta"},{"location":"wallet/Wallet/#errori_1","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice_1","text":"","title":"Codice"},{"location":"wallet/Wallet/#android_1","text":"// Example 1: retrieve 6 activities of all type List<ActivityType> types = ActivityType.all; ActivityListParams params = new ActivityListParams(types, Currency.EUR); // Example 2: retrieve 10 sell activities List<ActivityType> types = Collections.singletonList(ActivityType.SELL); ActivityListParams params = new ActivityListParams(types, Currency.EUR, 10); // Example 3: retrieve 6 buy and receive activities of the last month List<ActivityType> types = Arrays.asList(ActivityType.BUY, ActivityType.RECEIVE); ActivityListParams params = new ActivityListParams( types, // types Currency.EUR, // currency 6, // limit null, // nextPage TimeFrame.lastMonth() // timeFrame ); conio.walletService.activityList(params) .asCallback(result -> result.analysis( activityList -> { /* Handle ActivityList */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios_1","text":"let types = WalletActivityType.allCases let params = ActivitiesParams(nextPage: \"string\", types: types) conio.walletService.walletActivities(params: params).asCallback { result in switch result { case .success(let activities): // WalletActivities case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/#dettaglio-di-un-movimento","text":"Recuperata la lista delle attivit\u00e0 \u00e8 possibile ottenere ulteriori informazioni su un Activity specifica richiedendone il dettaglio.","title":"Dettaglio di un movimento"},{"location":"wallet/Wallet/#metodo_2","text":"walletService.activityDetails","title":"Metodo"},{"location":"wallet/Wallet/#parametri_1","text":"Un oggetto di tipo ActivityDetailsParams contenente: activityId : di tipo String , l'id dell' Activity della quale si vuole leggere il dettaglio; currency : di tipo Currency , la valuta nella quale si vuole conoscere il valore della transazioni di acquisto e vendita (attualmente solo Euro);","title":"Parametri"},{"location":"wallet/Wallet/#risposta_2","text":"Un oggetto di tipo ActivityDetails contenente: activityId : di tipo String , l'id dell'attivit\u00e0; type : di tipo ActivityType , la tipologia di Activity ( SEND , BUY , SELL , RECEIVE ); createdAt : di tipo Long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi. @Opzionale transaction : di tipo Transaction , la transazione annessa. Popolato nel caso in cui sia stata effettuata una transazione. Contiene informazioni sulla transazione Bitcoin associata all' Activity , quali: hash : di tipo String , l'hash della transazione Bitcoin; status : di tipo TransactionStatus , lo stato di conferma della transazione Bitcoin legata all' Activity ( UNCONFIRMED , PARTIALLY_CONFIRMED , CONFIRMED ); type : di tipo TransactionType , il tipo di transazione Bitcoin ( GENERIC o REDEPOSIT , ovvero una transazione verso se stessi); addresses : di tipo List<String> , gli indirizzi Bitcoin dei dei mittenti (per le transazioni in entrata) o dei destinatari (per le transazioni in uscita); cryptoAmount : di tipo long miningFees : di tipo long , le commissioni pagate alle rete Bitcoin per processare la transazione; isIncoming : di tipo booleano , flag indicante se la transazione \u00e8 in entrata o in uscita rispetto al portafoglio dell'utente; isLocal : di tipo booleano , flag indicante se la transazione \u00e8 stata ricevuta/inviata da/a un portafoglio Conio. @Opzionale associatedBid : l'offerta di acquisto annessa. Popolato in caso di attivit\u00e0 di acquisto. Contiene le informazioni sulla richiesta di acquisto, quali: status : di tipo BidStatus , lo stato del pagamento della richiesta di acquisto ( PAID , CHARGED ); cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) acquistato; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il controvalore (rispetto al cryptoAmount ) accordato per l'acquisto dei bitcoin, calcolato nella valuta indicata dal campo currency ; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni pagate per la fruizione del servizio, calcolato nella valuta indicata dal campo currency ; currency : di tipo Currency , la valuta usata per l'acquisto dei bitcoin; paymentMethodId : di tipo String , l'identificativo del metodo di pagamento; createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi; paidAt : di tipo long , l'istante temporale in cui \u00e8 stato effettuato il pagamento per l'acquisto dei bitcoin, espresso come Unix Timestamp in millisecondi; @Opzionale chargedAt : di tipo long , l'istante temporale in cui \u00e8 stata invaita la transazione bitcoin, espresso come Unix Timestamp in millisecondi. Nullo nel caso in cui la transazione non sia ancora stata effettuata. @Opzionale associatedAsk : l'offerta di vendita annessa. Popolato in caso di attivit\u00e0 di vendita, Contiene le informazioni sulla richeista di vendita, quali: status : di tipo AskStatus , lo stato del pagamento della richiesta di vendita ( CHARGED , PAID ) cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) venduto; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il controvalore (rispetto al cryptoAmount ) accordato per la vendita dei bitcoin, calcolato nella valuta indicata dal campo currency ; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni pagate per la fruizione del servizio, calcolato nella valuta indicata dal campo currency ; currency : di tipo Currency , la valuta usata per la vendita dei bitcoin; sellMethodId : di tipo String , l'identificativo del metodo di riscossione della vendita; cro : di tipo String , il Codice Riferimento Operazione della transazione bancaria; iban : di tipo String , l'IBAN del richiedente del bonifico bancario; createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi; chargedAt : di tipo long , l'istante temporale in cui \u00e8 stata invaita la transazione bitcoin, espresso come Unix Timestamp in millisecondi; @Opzionale paidAt : di tipo long , l'istante temporale in cui \u00e8 stato effettuato il pagamento per la vendita dei bitcoin, espresso come Unix Timestamp in millisecondi. Nullo nel caso in cui la transazione non sia ancora stata effettuata.","title":"Risposta"},{"location":"wallet/Wallet/#errori_2","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice_2","text":"","title":"Codice"},{"location":"wallet/Wallet/#android_2","text":"ActivityDetailsParams params = new ActivityDetailsParams(\"activityId\", Currency.EUR); conio.walletService.activityDetails(params) .asCallback(result -> result.analysis( details -> { /* Handle ActivityDetails */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios_2","text":"let params = ActivityDetailsParams(activityId: \"activityId\", currency: .eur) conio.walletService.activityDetails(params: params).asCallback { result in switch result { case .success(let details): // ActivityDetails case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/#bilancio-del-portafoglio","text":"Permette di recuperare il bilancio del portafoglio Bitcoin dell'utente.","title":"Bilancio del portafoglio"},{"location":"wallet/Wallet/#metodo_3","text":"walletService.walletBalances","title":"Metodo"},{"location":"wallet/Wallet/#risposta_3","text":"Un oggetto di tipo WalletBalances contenente il valore di bitcoin presente nel wallet espresso in satoshi (1 bitcoin = 100.000.000 satoshi). Il valore si divide in: confirmedBalance : di tipo long , valore con almeno 3 conferme sulla blockchain Bitcoin e quindi disponibile per l'utente; unconfirmedBalance : di tipo long , valore con meno di 3 conferme e quindi non ancora disponibile.","title":"Risposta"},{"location":"wallet/Wallet/#errori_3","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice_3","text":"","title":"Codice"},{"location":"wallet/Wallet/#android_3","text":"conio.walletService.walletBalances() .asCallback(result -> result.analysis( balances -> { /* Handle WalletBalances */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios_3","text":"conio.walletService.walletBalances().asCallback { result in switch result { case .success(let balances): // WalletBalances case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/#codice-di-recupero-bitcoin","text":"Permette di recuperare dalla memoria del dispositivo il \"Codie di recupero Bitcoin\": 12 parole di backup del portafoglio Bitcoin.","title":"Codice di recupero Bitcoin"},{"location":"wallet/Wallet/#risposta_4","text":"Un oggetto di tipo MnemonicWords contenente un array di 12 stringhe.","title":"Risposta"},{"location":"wallet/Wallet/#errori_4","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice_4","text":"","title":"Codice"},{"location":"wallet/Wallet/#android_4","text":"conio.walletService.readMnemonic() .asCallback(result -> result.analysis( mnemonic -> { /* Handle MnemonicWords */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios_4","text":"conio.walletService.readMnemonic().asCallback { result in switch result { case .success(let mnemonic): // MnemonicWords case .failure(let error): // Operation Error } }","title":"iOS"}]}