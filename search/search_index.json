{"config":{"indexing":"full","lang":["it"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"English Conio Questo SDK rende semplice integrare un portafoglio Bitcoin Conio nella propria app. Cosa si pu\u00f2 fare? Creare un portafoglio Bitcoin Ottenere le informazioni del portafoglio creato Comprare e Vendere Bitcoin Leggere il dettaglio storico delle operazioni di un utente Ottenere il prezzo storico ed attuale del Bitcoin Come posso utilizzarlo? Installazione Android iOS Configurazione Operazioni Introduzione Operazioni sull'utente Termini di servizio Signup Login Logout Operazioni sul portafoglio Indirizzo bitcoin attuale Lista dei movimenti Dettaglio di un movimento Bilancio del portafoglio Codice di recupero Bitcoin Operazioni sul mercato Prezzo attuale del Bitcoin Prezzo storico del Bitcoin Riepilogo trading Commissioni trading Limiti di trading Acquisto di Bitcoin Vendita di Bitcoin","title":"home"},{"location":"#conio","text":"Questo SDK rende semplice integrare un portafoglio Bitcoin Conio nella propria app.","title":"Conio"},{"location":"#cosa-si-puo-fare","text":"Creare un portafoglio Bitcoin Ottenere le informazioni del portafoglio creato Comprare e Vendere Bitcoin Leggere il dettaglio storico delle operazioni di un utente Ottenere il prezzo storico ed attuale del Bitcoin","title":"Cosa si pu\u00f2 fare?"},{"location":"#come-posso-utilizzarlo","text":"Installazione Android iOS Configurazione Operazioni Introduzione Operazioni sull'utente Termini di servizio Signup Login Logout Operazioni sul portafoglio Indirizzo bitcoin attuale Lista dei movimenti Dettaglio di un movimento Bilancio del portafoglio Codice di recupero Bitcoin Operazioni sul mercato Prezzo attuale del Bitcoin Prezzo storico del Bitcoin Riepilogo trading Commissioni trading Limiti di trading Acquisto di Bitcoin Vendita di Bitcoin","title":"Come posso utilizzarlo?"},{"location":"CHANGELOG.en/","text":"Italiano: Questa pagina non \u00e8 tradotta in italiano Changelog iOS Android iOS 0.3.1 - 19-07-2021 Fixed Avoid using app bundle identifier during keychain init 0.3.0 - 14-07-2021 Changed Added missing filters params in ActivitiesParams to correctly get wallet activities Refactor on SDK errors: ConioError is now the only error type throwable (check operation section) 0.2.0 - 06-07-2021 Changed SDK configuration object ConioConfiguration has no default value and must be explicitly initialized Fixed Fix wrong privacy policies url mapping in GetLegalAcceptancesOperation Avoid build error on Xcode 12.4 in OpenAPIConioBuilder 0.1.6 - 25-06-2021 Changed Explicit fees represented as intervals WiretransferPayeeInfo in CreatedBid has now two dedicated properties representing standard and custom wire transfer payee info CreatedBid now contains net cost amount fiatAmount and gross amount grossFiatAmount All fiat amounts are now represented as Decimal 0.1.5 - 15-06-2021 Changed Models update Bid , Ask e Transaction properties linked to amount/balance now are declared with type UInt64 Added ConioError entity to map operation errors 0.1.4 - 10-06-2021 Changed Models update Bid , Ask , WalletBalances e SimpleActivity properties now have public control access Bid , Ask , WalletBalances e SimpleActivity properties linked to amount/balance now are declared with type UInt64 Removed Removed SwiftyRSA from dependencies included in ConioSDK 0.1.3 - 03-06-2021 Fixed Correzione errore signup operation 0.1.0 - 12-04-2021 Added Rilascio versione 0.1.0 Android 0.5.1 - 14-07-2021 Fixed Fix factory methods of TimeFrame class 0.5.0 - 06-07-2021 Changed SDK configuration object ConioConfiguration has no default value and must be explicitly initialized 0.4.8 - 25-06-2021 Changed Explicit fees represented as intervals WiretransferPayeeInfo in CreatedBid has now two dedicated properties representing standard and custom wire transfer payee info CreatedBid now contains net cost amount fiatAmount and gross amount grossFiatAmount All fiat amounts are now represented as BigDecimal Removed Removed type property from ServiceFee entity Renamed id property of model entities: CreatedAsk.id -> CreatedAsk.askId CreatedBid.id -> CreatedBid.bidId SimpleActivity.id -> SimpleActivity.activityId ActivityDetails.id -> ActivityDetails.activityId Added ConioError : INVALID_CRYPTO_PROOF, CRYPTO_PROOF_EXPIRED 0.4.7 - 01-06-2021 Added Aggiunta di weightedBidBalance alle TradingInfo : controvalore investito modified Modifica alle TradingFees : supporto fasce di commissioni 0.4.2 - 13-04-2021 Added Rilascio versione 0.4.2 0.4.1 - 12-04-2021 Added Rilascio versione 0.4.1","title":"Changelog (English)"},{"location":"CHANGELOG.en/#changelog","text":"iOS Android","title":"Changelog"},{"location":"CHANGELOG.en/#ios","text":"","title":"iOS"},{"location":"CHANGELOG.en/#031-19-07-2021","text":"","title":"0.3.1 - 19-07-2021"},{"location":"CHANGELOG.en/#fixed","text":"Avoid using app bundle identifier during keychain init","title":"Fixed"},{"location":"CHANGELOG.en/#030-14-07-2021","text":"","title":"0.3.0 - 14-07-2021"},{"location":"CHANGELOG.en/#changed","text":"Added missing filters params in ActivitiesParams to correctly get wallet activities Refactor on SDK errors: ConioError is now the only error type throwable (check operation section)","title":"Changed"},{"location":"CHANGELOG.en/#020-06-07-2021","text":"","title":"0.2.0 - 06-07-2021"},{"location":"CHANGELOG.en/#changed_1","text":"SDK configuration object ConioConfiguration has no default value and must be explicitly initialized","title":"Changed"},{"location":"CHANGELOG.en/#fixed_1","text":"Fix wrong privacy policies url mapping in GetLegalAcceptancesOperation Avoid build error on Xcode 12.4 in OpenAPIConioBuilder","title":"Fixed"},{"location":"CHANGELOG.en/#016-25-06-2021","text":"","title":"0.1.6 - 25-06-2021"},{"location":"CHANGELOG.en/#changed_2","text":"Explicit fees represented as intervals WiretransferPayeeInfo in CreatedBid has now two dedicated properties representing standard and custom wire transfer payee info CreatedBid now contains net cost amount fiatAmount and gross amount grossFiatAmount All fiat amounts are now represented as Decimal","title":"Changed"},{"location":"CHANGELOG.en/#015-15-06-2021","text":"","title":"0.1.5 - 15-06-2021"},{"location":"CHANGELOG.en/#changed_3","text":"Models update Bid , Ask e Transaction properties linked to amount/balance now are declared with type UInt64","title":"Changed"},{"location":"CHANGELOG.en/#added","text":"ConioError entity to map operation errors","title":"Added"},{"location":"CHANGELOG.en/#014-10-06-2021","text":"","title":"0.1.4 - 10-06-2021"},{"location":"CHANGELOG.en/#changed_4","text":"Models update Bid , Ask , WalletBalances e SimpleActivity properties now have public control access Bid , Ask , WalletBalances e SimpleActivity properties linked to amount/balance now are declared with type UInt64","title":"Changed"},{"location":"CHANGELOG.en/#removed","text":"Removed SwiftyRSA from dependencies included in ConioSDK","title":"Removed"},{"location":"CHANGELOG.en/#013-03-06-2021","text":"","title":"0.1.3 - 03-06-2021"},{"location":"CHANGELOG.en/#fixed_2","text":"Correzione errore signup operation","title":"Fixed"},{"location":"CHANGELOG.en/#010-12-04-2021","text":"","title":"0.1.0 - 12-04-2021"},{"location":"CHANGELOG.en/#added_1","text":"Rilascio versione 0.1.0","title":"Added"},{"location":"CHANGELOG.en/#android","text":"","title":"Android"},{"location":"CHANGELOG.en/#051-14-07-2021","text":"","title":"0.5.1 - 14-07-2021"},{"location":"CHANGELOG.en/#fixed_3","text":"Fix factory methods of TimeFrame class","title":"Fixed"},{"location":"CHANGELOG.en/#050-06-07-2021","text":"","title":"0.5.0 - 06-07-2021"},{"location":"CHANGELOG.en/#changed_5","text":"SDK configuration object ConioConfiguration has no default value and must be explicitly initialized","title":"Changed"},{"location":"CHANGELOG.en/#048-25-06-2021","text":"","title":"0.4.8 - 25-06-2021"},{"location":"CHANGELOG.en/#changed_6","text":"Explicit fees represented as intervals WiretransferPayeeInfo in CreatedBid has now two dedicated properties representing standard and custom wire transfer payee info CreatedBid now contains net cost amount fiatAmount and gross amount grossFiatAmount All fiat amounts are now represented as BigDecimal","title":"Changed"},{"location":"CHANGELOG.en/#removed_1","text":"Removed type property from ServiceFee entity Renamed id property of model entities: CreatedAsk.id -> CreatedAsk.askId CreatedBid.id -> CreatedBid.bidId SimpleActivity.id -> SimpleActivity.activityId ActivityDetails.id -> ActivityDetails.activityId","title":"Removed"},{"location":"CHANGELOG.en/#added_2","text":"ConioError : INVALID_CRYPTO_PROOF, CRYPTO_PROOF_EXPIRED","title":"Added"},{"location":"CHANGELOG.en/#047-01-06-2021","text":"","title":"0.4.7 - 01-06-2021"},{"location":"CHANGELOG.en/#added_3","text":"Aggiunta di weightedBidBalance alle TradingInfo : controvalore investito","title":"Added"},{"location":"CHANGELOG.en/#modified","text":"Modifica alle TradingFees : supporto fasce di commissioni","title":"modified"},{"location":"CHANGELOG.en/#042-13-04-2021","text":"","title":"0.4.2 - 13-04-2021"},{"location":"CHANGELOG.en/#added_4","text":"Rilascio versione 0.4.2","title":"Added"},{"location":"CHANGELOG.en/#041-12-04-2021","text":"","title":"0.4.1 - 12-04-2021"},{"location":"CHANGELOG.en/#added_5","text":"Rilascio versione 0.4.1","title":"Added"},{"location":"index.en/","text":"Italiano Conio This SDK makes it simple to integrate a Bitcoin wallet Conio in your app. What can you do? Create a Bitcoin wallet Show wallet details Show the historical and current Bitcoin price Send and receive Bitcoin Buy and Sell Bitcoin Show all the transactions made by the wallet How does it work? Installation Android iOS Configuration User Terms of service Signup Login Logout Wallet Bitcoin address Movements list Activity details Wallet details Send Bitcoin Market Bitcoin Price Historical Price Trading limits Trade Bitcoin General exceptions Outdated SDK","title":"Home"},{"location":"index.en/#conio","text":"This SDK makes it simple to integrate a Bitcoin wallet Conio in your app.","title":"Conio"},{"location":"index.en/#what-can-you-do","text":"Create a Bitcoin wallet Show wallet details Show the historical and current Bitcoin price Send and receive Bitcoin Buy and Sell Bitcoin Show all the transactions made by the wallet","title":"What can you do?"},{"location":"index.en/#how-does-it-work","text":"Installation Android iOS Configuration User Terms of service Signup Login Logout Wallet Bitcoin address Movements list Activity details Wallet details Send Bitcoin Market Bitcoin Price Historical Price Trading limits Trade Bitcoin General exceptions Outdated SDK","title":"How does it work?"},{"location":"configuration/Configuration.en/","text":"Italiano Initialize the SDK Conio object The Conio object needs to be initialized with a ConioConfiguration . You can use the test configuration that will connect to the staging environment and the Bitcoin testnet blockchain. The prod environment instead will connect to the production server and the Bitcoin original blockchain. You can also initialize the SDK with a custom environment, with the url of the backend and a Bitcoin blockchain. Parameters configuration : configuration to initialize the SDK: ConioConfiguration type (Android) context : context will save in the Shared Preferences Conio Configuration identifier : name of the configuration bitcoinNetwork : the Bitcoin network, either .testnet or .mainnet networkEnvironment : the environment (which backend): NetworkEnvironment type Network Environment name : name of the environment host : the host Code Android import com.conio.sdk.Conio; import com.conio.sdk.models.shared.BitcoinNetwork; import com.conio.sdk.models.shared.ConioConfiguration; import com.conio.sdk.providers.networking.NetworkEnvironment; // Test configuration Conio conio = new Conio(ConioConfiguration.test, getApplicationContext()); // Production configuration Conio conio = new Conio(ConioConfiguration.prod, getApplicationContext()); iOS import ConioSDK // Test configuration let conio = Conio(configuration: ConioConfiguration.test) // Production configuration let conio = Conio(configuration: ConioConfiguration.prod)","title":"Configuration"},{"location":"configuration/Configuration.en/#initialize-the-sdk","text":"","title":"Initialize the SDK"},{"location":"configuration/Configuration.en/#conio-object","text":"The Conio object needs to be initialized with a ConioConfiguration . You can use the test configuration that will connect to the staging environment and the Bitcoin testnet blockchain. The prod environment instead will connect to the production server and the Bitcoin original blockchain. You can also initialize the SDK with a custom environment, with the url of the backend and a Bitcoin blockchain.","title":"Conio object"},{"location":"configuration/Configuration.en/#parameters","text":"configuration : configuration to initialize the SDK: ConioConfiguration type (Android) context : context will save in the Shared Preferences","title":"Parameters"},{"location":"configuration/Configuration.en/#conio-configuration","text":"identifier : name of the configuration bitcoinNetwork : the Bitcoin network, either .testnet or .mainnet networkEnvironment : the environment (which backend): NetworkEnvironment type","title":"Conio Configuration"},{"location":"configuration/Configuration.en/#network-environment","text":"name : name of the environment host : the host","title":"Network Environment"},{"location":"configuration/Configuration.en/#code","text":"","title":"Code"},{"location":"configuration/Configuration.en/#android","text":"import com.conio.sdk.Conio; import com.conio.sdk.models.shared.BitcoinNetwork; import com.conio.sdk.models.shared.ConioConfiguration; import com.conio.sdk.providers.networking.NetworkEnvironment; // Test configuration Conio conio = new Conio(ConioConfiguration.test, getApplicationContext()); // Production configuration Conio conio = new Conio(ConioConfiguration.prod, getApplicationContext());","title":"Android"},{"location":"configuration/Configuration.en/#ios","text":"import ConioSDK // Test configuration let conio = Conio(configuration: ConioConfiguration.test) // Production configuration let conio = Conio(configuration: ConioConfiguration.prod)","title":"iOS"},{"location":"configuration/Configuration/","text":"English Inizializzazione dell'SDK L'oggetto Conio Per usare l'SDK, occorre inizializzare l'oggetto Conio con una ConioConfiguration . La configurazione determiner\u00e0 l'ambiente con il quale l'SDK interagir\u00e0. Possono essere utilizzate due configurazioni principali: test , che si interfaccer\u00e0 con l'ambiente di staging (rete Bitcoin: testnet ). production , che si interfaccer\u00e0 con l'ambiente di produzione (rete Bitcoin: mainnet ). \u00c8 necessario inizializzare l'SDK con un ambiente personalizzato, specificando l'url del backend e la rete Bitcoin da utilizzare. Di seguito le specifiche per inizializzare un oggetto di tipo Conio . Parametri: Conio configuration : di tipo ConioConfiguration , la configurazione per inizializzare l'SDK; (Android) context : di tipo Context , il context dell'applicazione Android. Parametri: ConioConfiguration baseUrl : di tipo String , url del backend; bitcoinNetwork : di tipo BitcoinNetwork , la rete Bitcoin. Pu\u00f2 essere .testnet o .mainnet . Codice Android import com.conio.sdk.Conio; import com.conio.sdk.models.shared.BitcoinNetwork; import com.conio.sdk.models.shared.ConioConfiguration; import com.conio.sdk.providers.networking.NetworkEnvironment; // Test configuration ConioConfiguration testConfig = new ConioConfiguration(\"https://example.test.com\", BitcoinNetwork.TESTNET); Conio conio = new Conio(testConfig, context); // Production configuration ConioConfiguration config = new ConioConfiguration(\"https://example.production.com\", BitcoinNetwork.MAINNET); Conio conio = new Conio(config, context); iOS import ConioSDK // Test configuration let testConfig = ConioConfiguration( withBaseUrl: \"https://example.test.com\", bitcoinNetwork: .testnet ) let conio = Conio(config: testConfig) // Production configuration let config = ConioConfiguration( withBaseUrl: \"https://example.production.com\", bitcoinNetwork: .testnet ) let conio = Conio(config: config)","title":"configuration"},{"location":"configuration/Configuration/#inizializzazione-dellsdk","text":"","title":"Inizializzazione dell'SDK"},{"location":"configuration/Configuration/#loggetto-conio","text":"Per usare l'SDK, occorre inizializzare l'oggetto Conio con una ConioConfiguration . La configurazione determiner\u00e0 l'ambiente con il quale l'SDK interagir\u00e0. Possono essere utilizzate due configurazioni principali: test , che si interfaccer\u00e0 con l'ambiente di staging (rete Bitcoin: testnet ). production , che si interfaccer\u00e0 con l'ambiente di produzione (rete Bitcoin: mainnet ). \u00c8 necessario inizializzare l'SDK con un ambiente personalizzato, specificando l'url del backend e la rete Bitcoin da utilizzare. Di seguito le specifiche per inizializzare un oggetto di tipo Conio .","title":"L'oggetto Conio"},{"location":"configuration/Configuration/#parametri-conio","text":"configuration : di tipo ConioConfiguration , la configurazione per inizializzare l'SDK; (Android) context : di tipo Context , il context dell'applicazione Android.","title":"Parametri: Conio"},{"location":"configuration/Configuration/#parametri-conioconfiguration","text":"baseUrl : di tipo String , url del backend; bitcoinNetwork : di tipo BitcoinNetwork , la rete Bitcoin. Pu\u00f2 essere .testnet o .mainnet .","title":"Parametri: ConioConfiguration"},{"location":"configuration/Configuration/#codice","text":"","title":"Codice"},{"location":"configuration/Configuration/#android","text":"import com.conio.sdk.Conio; import com.conio.sdk.models.shared.BitcoinNetwork; import com.conio.sdk.models.shared.ConioConfiguration; import com.conio.sdk.providers.networking.NetworkEnvironment; // Test configuration ConioConfiguration testConfig = new ConioConfiguration(\"https://example.test.com\", BitcoinNetwork.TESTNET); Conio conio = new Conio(testConfig, context); // Production configuration ConioConfiguration config = new ConioConfiguration(\"https://example.production.com\", BitcoinNetwork.MAINNET); Conio conio = new Conio(config, context);","title":"Android"},{"location":"configuration/Configuration/#ios","text":"import ConioSDK // Test configuration let testConfig = ConioConfiguration( withBaseUrl: \"https://example.test.com\", bitcoinNetwork: .testnet ) let conio = Conio(config: testConfig) // Production configuration let config = ConioConfiguration( withBaseUrl: \"https://example.production.com\", bitcoinNetwork: .testnet ) let conio = Conio(config: config)","title":"iOS"},{"location":"exchange/Exchange.en/","text":"Italiano Exchange operations Current Bitcoin Price You can get the current buy or sell Bitcoin price. The SDK can also give you the Bitcoin equivalent for a set amount of currency. Parameters An object of type CurrentPriceParams : currency : which fiat currency (EUR) you want to have the exchange rate for. @Optional amount : the amount of Fiat currency (EUR) that you want to know the equivalent in BTC Returns A CurrentPrice object: buyPrice : Buy exchange rate sellPrice : Sell exchange rate timestamp : price timestamp Code Android // Current price CurrentPriceParams params = new CurrentPriceParams(Currency.EUR); // Conversion of 50.000.000 satoshi (0,5 BTC) in euro CurrentPriceParams params = new CurrentPriceParams(Currency.EUR, 50_000_000L) conio.exchangeService.currentPrice(params, result->{ result.analysis(price-> { // CurrentPrice }, error-> { // Exception }); }); iOS // Current price let params = CurrentPriceParams(currency: .eur) // Conversion of 50.000.000 satoshi (0,5 BTC) in euro let params = CurrentPriceParams(currency: .eur, satoshiAmount: 50_000_000) conio.exchangeService.currentPrice(params: params) { result in result.analysis(ifSuccess: { prices in // CurrentPrice }, ifFailure: { error in // ServiceError }) }); Bitcoin hystorical price You can get the Bitcoin hystorical price during a set amount of time. Parameters An object HistoricalPriceParams : currency : which fiat currency you want to have the exchange rate for. startTimestamp : Initial timestamp. endTimestamp : Final timespamp. @Optional interval : Time between each price (week, day, hour...) Returns Object HistoricalPrices : Contains a list of CurrentPrice An object PriceAnalytics containing: deltaFiat : absolute exchange rate change during the selected period. deltaPercentage : percentage change of the exchange rate during the selected period. trend : enum: price increased, decreased or stayed the same. Code Android // Price from April 16, 2019 to April 16, 2018 // Standard Interval: 1 day HistoricalPriceParams params = new HistoricalPriceParams( Currency.EUR, 1523885446000L, 1563465540000L ); // Price from April 16, 2019 to April 16, 2018 // Selected Interval: 1 week HistoricalPriceParams params = new HistoricalPriceParams( Currency.EUR, 1523885446000L, 1563465540000L, 604800000 ); conio.exchangeService.historicalPrices(params, result->{ result.analysis(prices-> { // HistoricalPrices }, error-> { // Exception }); }); iOS // Price from April 16, 2019 to April 16, 2018 // Standard Interval: 1 day let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000) // Price from April 16, 2019 to April 16, 2018 // Selected Interval: 1 week let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000, interval: 604800000) conio.exchangeService.historicalPrices(params: params) { result in result.analysis(ifSuccess: { prices in // HistoricalPrices }, ifFailure: { error in // ServiceError }) }); Trading limits Request user trading limits (assigned at signup) Returns An object AllTradingLimits (Android) or Limits (iOS) containing: Two objects: TradingLimits , one for buying limits and one for selling limits. Inside of it we get: currentLimit : current limit limits : a list containing each limit (daily, monthly, yearly) and their maximum values. currentLimitsByType : current limit for each of the limits. minimumBuyAmount : minimum amount in fiat currency (EUR) required to buy Bitcoin minimumSellAmount : minimum amount in fiat currency (EUR) required to sell Bitcoin Codice Android conio.exchangeService.tradingLimits(result -> { result.analysis(limits -> { // TradingLimits }, error -> { // Exception }); }); iOS conio.exchangeService.tradingLimits { result in result.analysis(ifSuccess: { limits in // TradingLimits }, ifFailure: { error in // ServiceError }) }); Buy Bitcoin In order to buy Bitcoin you will have to perform 2 operations. The first one creates a Bid (a request to buy some BTC at some price). Inside the created Bid you will find the WiretransferInfo that you will use to make the wire transfer necessary to pay for the Bitcoin. Once the wire transfer is completed you can perfom the second operation that will inform Conio that you payed the Bid by sending over a CryptoProof , required to proof the validity of the transaction. Bid creation You can create a RequestBid with a currency (BTC or EUR) and an amount, expressed either in satoshi, or in Fiat currency. For example you can create a RequestBid in Euro to buy an amount in Bitcoin for the equivalent of 20\u20ac, or a RequestBid in Euro to buy 100.000.000 satoshi. If the request will be successful you will get a Bid containing an ID . With this identifier you will be able to update the Bid to get fresh info about it. This will be necessary if the user takes some time (more than 2 minutes) from the Bid request to the actual payment. Parameters (Optional) id : Bid id, insert only if you need to refresh the bid (one of) satoshi : amount of Bitcoin that the user wants to buy (one of) fiatAmount : amount of Fiat currency the user wants to spend to buy an equivalent Bitcoin amount currency : Fiat currency used to buy (EUR) The SDK will allow you to insert only one of satoshi or fiatAmount . You should never input both of them at the same time. Returns An object CreatedBid containing: id : identifier required to refresh or finalize a bid currency : Fiat currency used to buy (EUR) satoshi : Satoshi amount of the request fiatAmount : Fiat amount (EUR) of the request serviceFees : Fees for the transaction in the selected currency expiration : Bid expiration timestamp. If expired please refresh the Bid. wiretransferInfo : necessary info to pay for the bid Code Android // Buy request for 100\u20ac CreateOrRefreshBidParams params = new CreateOrRefreshBidParams(Currency.EUR, 100d); // Buy request for 1.000.000 satoshi CreateOrRefreshBidParams params = new CreateOrRefreshBidParams(Currency.EUR, 100000000l); // Bid refresh for 100\u20ac CreateOrRefreshBidParams params = new CreateOrRefreshBidParams( \"bididentifier\", Currency.EUR, 100d ); conio.exchangeService.createOrRefreshBid(params, result -> { result.analysis(bid -> { // CreatedBid }, error -> { // Exception }); }); iOS // Buy request for 50\u20ac let params = CreateOrRefreshBidParams(currency: .eur, fiatAmount: 50.0) // Buy request for 1.000.000 satoshi let params = CreateOrRefreshBidParams(currency: .eur, satoshi: 1000000) // Bid refresh for 100\u20ac let params = CreateOrRefreshBidParams(bidID: \"bididentifier\", currency: .eur, fiatAmount: 100.0) conio.exchangeService.createOrRefreshBid(params: params) { result in result.analysis(ifSuccess: { createdBid in // CreatedBid }, ifFailure: { error in // ServiceError }) }); Bid Payment Once you have payed the Bid you can use the Purchase operation to receive the Bitcoin. You will have to submit a CryptoProof , that you can create in the same way as the one created during the signup. The only difference is the following DATA to concatenate (exactly in this order): [proofID, \"PAY_FOR_BID_WT\", bidID, userID, Expiration] Parameters An object PurchaseParams containing: bidId : Bid identifier referring to the bid you want to finalize cryptoRequest : a BidCryptoRequest Returns An object PurchaseResult containing: bidId : Bid identifier Errors INVALID_CRYPTO_PROOF Crypto proof is not valid INVALID_PAYMENT_METHOD Payment method is not valid UNSUPPORTED_PAYMENT_METHOD Payment method is not supported TRADING_LIMITS_EXCEEDED Bid exceed the maximum buy limit of the user TRADE_EXPIRED Bid is expired BID_ALREADY_PAID Bid was already paid BID_NOT_YET_PAID Bid has not been paid yet UNRECOVERABLE_BID Bid is in an error state FIAT_AMOUNT_TOO_LOW Fiat amount is lower than minimum limit Code Android BidCryptoRequest bidCryptoRequest = createCryptoRequest() // Your implementation PurchaseParams params = new PurchaseParams(\"bidId\", bidCryptoRequest, card); conio.exchangeService.purchase(params, result -> { result.analysis(bid -> { // PurchaseResult }, error -> { // Exception }); }); iOS let cryptoRequest = createCryptoRequest() // Your implementation let params = PurchaseParams(bidID: \"bidID\", paymentCard: card, cryptoRequest: cryptoRequest) conio.exchangeService.purchase(params: params) { result in result.analysis(ifSuccess: { bid in // PurchaseResult }, ifFailure: { error in // ServiceError }) }); Sell Bitcoin In order to buy Bitcoin you will have to perform 2 operations. The first one creates a Ask (a request to sell some BTC at some price). The second one will pay said Ask , by using the ask identifier. The SDK will sign the Bitcoin transaction that moves the bitcoins from the user wallet, returning the id of said completed Ask. Ask Creation You can create a CreatedAsk in Euro to sell an amount in Bitcoin for the equivalent of 50\u20ac, or a CreatedAsk in Euro to sell 100.000.000 satoshi. The request will return an Ask containing an ID . With this identifier you will be able to update the Ask to get fresh info about it. This will be necessary if the user takes some time (more than 2 minutes) from the Ask request to the actual sell. Parameters (Optional) id : Ask id, insert only if you need to refresh the Ask (one of) satoshi : bitcoin amount the user wants to sell (one of) fiatAmount : amount of Fiat currency the user wants to receive when selling Bitcoin currency : Fiat currency to receive (EUR) The SDK will allow you to insert only one of satoshi or fiatAmount . You should never input both of them at the same time. Returns An object CreatedAsk containing: id : identifier required to refresh or finalize a ask currency : Fiat currency to receive (EUR) satoshi : Satoshi amount of the request fiatAmount : Fiat amount (EUR) of the request serviceFees : Fees for the transaction in the selected currency expiration : Ask expiration timestamp. If expired please refresh the Ask. minerFees : Bitcoin network fees, used to pay for the inclusion of the transaction in the blockchain. Errors TRADING_LIMITS_EXCEEDED NOT_ENOUGH_BTC_AMOUNT NO_SUCH_SELLER (Internal selling error) NO_SUCH_WALLET (Internal wallet error) iOS // Sell request for 50\u20ac let params = CreateOrRefreshAskParams(currency: .eur, fiatAmount: 50.0) // Sell request for 100000000 satoshi let params = CreateOrRefreshAskParams(currency: .eur, satoshi: 100000000) // Refresh ask let params = CreateOrRefreshAskParams(askID: \"id\", currency: .eur, fiatAmount: 100.0) conio.exchangeService.createOrRefreshAsk(params: params) { result in result.analysis(ifSuccess: { createdAsk in // CreatedBid }, ifFailure: { error in // ServiceError }) } Android // Sell request for 50\u20ac CreateOrRefreshAskParams params = new CreateOrRefreshAskParams(Currency.EUR, 50d); // Refresh ask CreateOrRefreshAskParams params = new CreateOrRefreshAskParams(\"id\", Currency.EUR, 50d); conio.exchangeService.createOrRefreshAsk(params: params) { result in result.analysis(ifSuccess: { createdAsk in // CreatedAsk }, ifFailure: { error in // Exception }) }); Finalize Ask To finalize the sell you just need to input the ID of the CreatedAsk in the Sell operation. Parameters An object SellParams containing: askId : Ask identifier Returns An object SellResult containing: askId : Ask identifier Errors TRADING_LIMITS_EXCEEDED TRADE_EXPIRED UNRECOVERABLE_ASK ASK_ALREADY_PAID NOT_ENOUGH_BTC_AMOUNT_E DUST_ASK (Bitcoin amount is too low) FIAT_AMOUNT_TOO_LOW Code iOS let params = SellParams(askID: askID) conio.exchangeService.sell(params: params) { result in result.analysis(ifSuccess: { sellResult in // SellResult }, ifFailure: { error in // ServiceError }) } Android SellParams sellParams = new SellParams(\"askId\"); conio.exchangeService.sell(params: params) { result in result.analysis(ifSuccess: { sellResult in // SellResult }, ifFailure: { error in // Exception }) });","title":"exchangeOperations"},{"location":"exchange/Exchange.en/#exchange-operations","text":"","title":"Exchange operations"},{"location":"exchange/Exchange.en/#current-bitcoin-price","text":"You can get the current buy or sell Bitcoin price. The SDK can also give you the Bitcoin equivalent for a set amount of currency.","title":"Current Bitcoin Price"},{"location":"exchange/Exchange.en/#parameters","text":"An object of type CurrentPriceParams : currency : which fiat currency (EUR) you want to have the exchange rate for. @Optional amount : the amount of Fiat currency (EUR) that you want to know the equivalent in BTC","title":"Parameters"},{"location":"exchange/Exchange.en/#returns","text":"A CurrentPrice object: buyPrice : Buy exchange rate sellPrice : Sell exchange rate timestamp : price timestamp","title":"Returns"},{"location":"exchange/Exchange.en/#code","text":"","title":"Code"},{"location":"exchange/Exchange.en/#android","text":"// Current price CurrentPriceParams params = new CurrentPriceParams(Currency.EUR); // Conversion of 50.000.000 satoshi (0,5 BTC) in euro CurrentPriceParams params = new CurrentPriceParams(Currency.EUR, 50_000_000L) conio.exchangeService.currentPrice(params, result->{ result.analysis(price-> { // CurrentPrice }, error-> { // Exception }); });","title":"Android"},{"location":"exchange/Exchange.en/#ios","text":"// Current price let params = CurrentPriceParams(currency: .eur) // Conversion of 50.000.000 satoshi (0,5 BTC) in euro let params = CurrentPriceParams(currency: .eur, satoshiAmount: 50_000_000) conio.exchangeService.currentPrice(params: params) { result in result.analysis(ifSuccess: { prices in // CurrentPrice }, ifFailure: { error in // ServiceError }) });","title":"iOS"},{"location":"exchange/Exchange.en/#bitcoin-hystorical-price","text":"You can get the Bitcoin hystorical price during a set amount of time.","title":"Bitcoin hystorical price"},{"location":"exchange/Exchange.en/#parameters_1","text":"An object HistoricalPriceParams : currency : which fiat currency you want to have the exchange rate for. startTimestamp : Initial timestamp. endTimestamp : Final timespamp. @Optional interval : Time between each price (week, day, hour...)","title":"Parameters"},{"location":"exchange/Exchange.en/#returns_1","text":"Object HistoricalPrices : Contains a list of CurrentPrice An object PriceAnalytics containing: deltaFiat : absolute exchange rate change during the selected period. deltaPercentage : percentage change of the exchange rate during the selected period. trend : enum: price increased, decreased or stayed the same.","title":"Returns"},{"location":"exchange/Exchange.en/#code_1","text":"","title":"Code"},{"location":"exchange/Exchange.en/#android_1","text":"// Price from April 16, 2019 to April 16, 2018 // Standard Interval: 1 day HistoricalPriceParams params = new HistoricalPriceParams( Currency.EUR, 1523885446000L, 1563465540000L ); // Price from April 16, 2019 to April 16, 2018 // Selected Interval: 1 week HistoricalPriceParams params = new HistoricalPriceParams( Currency.EUR, 1523885446000L, 1563465540000L, 604800000 ); conio.exchangeService.historicalPrices(params, result->{ result.analysis(prices-> { // HistoricalPrices }, error-> { // Exception }); });","title":"Android"},{"location":"exchange/Exchange.en/#ios_1","text":"// Price from April 16, 2019 to April 16, 2018 // Standard Interval: 1 day let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000) // Price from April 16, 2019 to April 16, 2018 // Selected Interval: 1 week let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000, interval: 604800000) conio.exchangeService.historicalPrices(params: params) { result in result.analysis(ifSuccess: { prices in // HistoricalPrices }, ifFailure: { error in // ServiceError }) });","title":"iOS"},{"location":"exchange/Exchange.en/#trading-limits","text":"Request user trading limits (assigned at signup)","title":"Trading limits"},{"location":"exchange/Exchange.en/#returns_2","text":"An object AllTradingLimits (Android) or Limits (iOS) containing: Two objects: TradingLimits , one for buying limits and one for selling limits. Inside of it we get: currentLimit : current limit limits : a list containing each limit (daily, monthly, yearly) and their maximum values. currentLimitsByType : current limit for each of the limits. minimumBuyAmount : minimum amount in fiat currency (EUR) required to buy Bitcoin minimumSellAmount : minimum amount in fiat currency (EUR) required to sell Bitcoin","title":"Returns"},{"location":"exchange/Exchange.en/#codice","text":"","title":"Codice"},{"location":"exchange/Exchange.en/#android_2","text":"conio.exchangeService.tradingLimits(result -> { result.analysis(limits -> { // TradingLimits }, error -> { // Exception }); });","title":"Android"},{"location":"exchange/Exchange.en/#ios_2","text":"conio.exchangeService.tradingLimits { result in result.analysis(ifSuccess: { limits in // TradingLimits }, ifFailure: { error in // ServiceError }) });","title":"iOS"},{"location":"exchange/Exchange.en/#buy-bitcoin","text":"In order to buy Bitcoin you will have to perform 2 operations. The first one creates a Bid (a request to buy some BTC at some price). Inside the created Bid you will find the WiretransferInfo that you will use to make the wire transfer necessary to pay for the Bitcoin. Once the wire transfer is completed you can perfom the second operation that will inform Conio that you payed the Bid by sending over a CryptoProof , required to proof the validity of the transaction.","title":"Buy Bitcoin"},{"location":"exchange/Exchange.en/#bid-creation","text":"You can create a RequestBid with a currency (BTC or EUR) and an amount, expressed either in satoshi, or in Fiat currency. For example you can create a RequestBid in Euro to buy an amount in Bitcoin for the equivalent of 20\u20ac, or a RequestBid in Euro to buy 100.000.000 satoshi. If the request will be successful you will get a Bid containing an ID . With this identifier you will be able to update the Bid to get fresh info about it. This will be necessary if the user takes some time (more than 2 minutes) from the Bid request to the actual payment.","title":"Bid creation"},{"location":"exchange/Exchange.en/#parameters_2","text":"(Optional) id : Bid id, insert only if you need to refresh the bid (one of) satoshi : amount of Bitcoin that the user wants to buy (one of) fiatAmount : amount of Fiat currency the user wants to spend to buy an equivalent Bitcoin amount currency : Fiat currency used to buy (EUR) The SDK will allow you to insert only one of satoshi or fiatAmount . You should never input both of them at the same time.","title":"Parameters"},{"location":"exchange/Exchange.en/#returns_3","text":"An object CreatedBid containing: id : identifier required to refresh or finalize a bid currency : Fiat currency used to buy (EUR) satoshi : Satoshi amount of the request fiatAmount : Fiat amount (EUR) of the request serviceFees : Fees for the transaction in the selected currency expiration : Bid expiration timestamp. If expired please refresh the Bid. wiretransferInfo : necessary info to pay for the bid","title":"Returns"},{"location":"exchange/Exchange.en/#code_2","text":"","title":"Code"},{"location":"exchange/Exchange.en/#android_3","text":"// Buy request for 100\u20ac CreateOrRefreshBidParams params = new CreateOrRefreshBidParams(Currency.EUR, 100d); // Buy request for 1.000.000 satoshi CreateOrRefreshBidParams params = new CreateOrRefreshBidParams(Currency.EUR, 100000000l); // Bid refresh for 100\u20ac CreateOrRefreshBidParams params = new CreateOrRefreshBidParams( \"bididentifier\", Currency.EUR, 100d ); conio.exchangeService.createOrRefreshBid(params, result -> { result.analysis(bid -> { // CreatedBid }, error -> { // Exception }); });","title":"Android"},{"location":"exchange/Exchange.en/#ios_3","text":"// Buy request for 50\u20ac let params = CreateOrRefreshBidParams(currency: .eur, fiatAmount: 50.0) // Buy request for 1.000.000 satoshi let params = CreateOrRefreshBidParams(currency: .eur, satoshi: 1000000) // Bid refresh for 100\u20ac let params = CreateOrRefreshBidParams(bidID: \"bididentifier\", currency: .eur, fiatAmount: 100.0) conio.exchangeService.createOrRefreshBid(params: params) { result in result.analysis(ifSuccess: { createdBid in // CreatedBid }, ifFailure: { error in // ServiceError }) });","title":"iOS"},{"location":"exchange/Exchange.en/#bid-payment","text":"Once you have payed the Bid you can use the Purchase operation to receive the Bitcoin. You will have to submit a CryptoProof , that you can create in the same way as the one created during the signup. The only difference is the following DATA to concatenate (exactly in this order): [proofID, \"PAY_FOR_BID_WT\", bidID, userID, Expiration]","title":"Bid Payment"},{"location":"exchange/Exchange.en/#parameters_3","text":"An object PurchaseParams containing: bidId : Bid identifier referring to the bid you want to finalize cryptoRequest : a BidCryptoRequest","title":"Parameters"},{"location":"exchange/Exchange.en/#returns_4","text":"An object PurchaseResult containing: bidId : Bid identifier","title":"Returns"},{"location":"exchange/Exchange.en/#errors","text":"INVALID_CRYPTO_PROOF Crypto proof is not valid INVALID_PAYMENT_METHOD Payment method is not valid UNSUPPORTED_PAYMENT_METHOD Payment method is not supported TRADING_LIMITS_EXCEEDED Bid exceed the maximum buy limit of the user TRADE_EXPIRED Bid is expired BID_ALREADY_PAID Bid was already paid BID_NOT_YET_PAID Bid has not been paid yet UNRECOVERABLE_BID Bid is in an error state FIAT_AMOUNT_TOO_LOW Fiat amount is lower than minimum limit","title":"Errors"},{"location":"exchange/Exchange.en/#code_3","text":"","title":"Code"},{"location":"exchange/Exchange.en/#android_4","text":"BidCryptoRequest bidCryptoRequest = createCryptoRequest() // Your implementation PurchaseParams params = new PurchaseParams(\"bidId\", bidCryptoRequest, card); conio.exchangeService.purchase(params, result -> { result.analysis(bid -> { // PurchaseResult }, error -> { // Exception }); });","title":"Android"},{"location":"exchange/Exchange.en/#ios_4","text":"let cryptoRequest = createCryptoRequest() // Your implementation let params = PurchaseParams(bidID: \"bidID\", paymentCard: card, cryptoRequest: cryptoRequest) conio.exchangeService.purchase(params: params) { result in result.analysis(ifSuccess: { bid in // PurchaseResult }, ifFailure: { error in // ServiceError }) });","title":"iOS"},{"location":"exchange/Exchange.en/#sell-bitcoin","text":"In order to buy Bitcoin you will have to perform 2 operations. The first one creates a Ask (a request to sell some BTC at some price). The second one will pay said Ask , by using the ask identifier. The SDK will sign the Bitcoin transaction that moves the bitcoins from the user wallet, returning the id of said completed Ask.","title":"Sell Bitcoin"},{"location":"exchange/Exchange.en/#ask-creation","text":"You can create a CreatedAsk in Euro to sell an amount in Bitcoin for the equivalent of 50\u20ac, or a CreatedAsk in Euro to sell 100.000.000 satoshi. The request will return an Ask containing an ID . With this identifier you will be able to update the Ask to get fresh info about it. This will be necessary if the user takes some time (more than 2 minutes) from the Ask request to the actual sell.","title":"Ask Creation"},{"location":"exchange/Exchange.en/#parameters_4","text":"(Optional) id : Ask id, insert only if you need to refresh the Ask (one of) satoshi : bitcoin amount the user wants to sell (one of) fiatAmount : amount of Fiat currency the user wants to receive when selling Bitcoin currency : Fiat currency to receive (EUR) The SDK will allow you to insert only one of satoshi or fiatAmount . You should never input both of them at the same time.","title":"Parameters"},{"location":"exchange/Exchange.en/#returns_5","text":"An object CreatedAsk containing: id : identifier required to refresh or finalize a ask currency : Fiat currency to receive (EUR) satoshi : Satoshi amount of the request fiatAmount : Fiat amount (EUR) of the request serviceFees : Fees for the transaction in the selected currency expiration : Ask expiration timestamp. If expired please refresh the Ask. minerFees : Bitcoin network fees, used to pay for the inclusion of the transaction in the blockchain.","title":"Returns"},{"location":"exchange/Exchange.en/#errors_1","text":"TRADING_LIMITS_EXCEEDED NOT_ENOUGH_BTC_AMOUNT NO_SUCH_SELLER (Internal selling error) NO_SUCH_WALLET (Internal wallet error)","title":"Errors"},{"location":"exchange/Exchange.en/#ios_5","text":"// Sell request for 50\u20ac let params = CreateOrRefreshAskParams(currency: .eur, fiatAmount: 50.0) // Sell request for 100000000 satoshi let params = CreateOrRefreshAskParams(currency: .eur, satoshi: 100000000) // Refresh ask let params = CreateOrRefreshAskParams(askID: \"id\", currency: .eur, fiatAmount: 100.0) conio.exchangeService.createOrRefreshAsk(params: params) { result in result.analysis(ifSuccess: { createdAsk in // CreatedBid }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"exchange/Exchange.en/#android_5","text":"// Sell request for 50\u20ac CreateOrRefreshAskParams params = new CreateOrRefreshAskParams(Currency.EUR, 50d); // Refresh ask CreateOrRefreshAskParams params = new CreateOrRefreshAskParams(\"id\", Currency.EUR, 50d); conio.exchangeService.createOrRefreshAsk(params: params) { result in result.analysis(ifSuccess: { createdAsk in // CreatedAsk }, ifFailure: { error in // Exception }) });","title":"Android"},{"location":"exchange/Exchange.en/#finalize-ask","text":"To finalize the sell you just need to input the ID of the CreatedAsk in the Sell operation.","title":"Finalize Ask"},{"location":"exchange/Exchange.en/#parameters_5","text":"An object SellParams containing: askId : Ask identifier","title":"Parameters"},{"location":"exchange/Exchange.en/#returns_6","text":"An object SellResult containing: askId : Ask identifier","title":"Returns"},{"location":"exchange/Exchange.en/#errors_2","text":"TRADING_LIMITS_EXCEEDED TRADE_EXPIRED UNRECOVERABLE_ASK ASK_ALREADY_PAID NOT_ENOUGH_BTC_AMOUNT_E DUST_ASK (Bitcoin amount is too low) FIAT_AMOUNT_TOO_LOW","title":"Errors"},{"location":"exchange/Exchange.en/#code_4","text":"","title":"Code"},{"location":"exchange/Exchange.en/#ios_6","text":"let params = SellParams(askID: askID) conio.exchangeService.sell(params: params) { result in result.analysis(ifSuccess: { sellResult in // SellResult }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"exchange/Exchange.en/#android_6","text":"SellParams sellParams = new SellParams(\"askId\"); conio.exchangeService.sell(params: params) { result in result.analysis(ifSuccess: { sellResult in // SellResult }, ifFailure: { error in // Exception }) });","title":"Android"},{"location":"exchange/Exchange/","text":"English Operazioni sul mercato Prezzo attuale del Bitcoin \u00c8 possibile recuperare il miglior prezzo di acquisto e di vendita attuale del bitcoin, specificando la valuta nel quale lo si vuole ottenere. Inoltre, l'SDK offre la possibilit\u00e0 di convertire un ammontare in bitcoin nella valuta specificata. Metodo exchangeService.currentPrice Parametri Un oggetto di tipo CurrentPriceParams contenente: currency : di tipo Currency , la valuta in cui si vuole ottenere il prezzo; @Opzionale cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) che si vuole convertire nella valuta indicata. Risposta Un CurrentPrice contenente: buyFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il prezzo di acquisto, calcolato nella valuta indicata tramite il campo currency ; sellFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il prezzo di vendita, calcolato nella valuta indicata tramite il campo currency . Codice Android // Example 1: get current price CurrentPriceParams params = new CurrentPriceParams(Currency.EUR); // Example 2: get current price of a specified amount CurrentPriceParams params = new CurrentPriceParams(Currency.EUR, 100000000); conio.exchangeService.currentPrice(params) .asCallback(result -> result.analysis( currentPrice -> { /* Handle CurrentPrice */ }, error -> { /* ... */ } )); iOS // Recupero del prezzo attuale let params = CurrentPriceParams(currency: .eur) // Conversione di 50.000.000 satoshi (0,5 BTC) in euro let params = CurrentPriceParams(currency: .eur, satoshiAmount: 50_000_000) let consumer = conio.exchangeService.currentPrice(params: params) consumer.asCallback { result in switch result { case .success(let prices): // CurrentPrice case .failure(let error): // Operation Error } } Prezzo storico del Bitcoin \u00c8 possibile recuperare il prezzo storico del Bitcoin selezionando una finestra temporale di riferimento. Metodo exchangeService.historicalPrices Parametri Un oggetto di tipo HistoricalPricesParams contenente: currency : di tipo Currency , la valuta in cui si vuole ottenere il prezzo; timeFrame : di tipo TimeFrame , la finestra temporale di riferimento; @Default(24h) interval : di tipo long , l'intervallo che si vuole porre tra i prezzi restituiti; Risposta Un HistoricalPrices contenente: prices : di tipo List<PricePoint> , la lista dei prezzi del bitcoin nella finestra temporale specificata; analytics : di tipo PriceAnalytics , contenente: deltaFiat : di tipo Decimal (iOS) / BigDecimal (Android), la variazione in valuta del prezzo del Bitcoin dall'inizio del periodo di riferimento; deltaPercentage : la variazione in percentuale del prezzo del Bitcoin dall'inizio del periodo di riferimento; trend : di tipo PriceTrend , un enumerato che rappresenta se il prezzo del Bitcoin, dall'inizio del periodo di riferimento, \u00e8 cresciuto, \u00e8 diminuito o \u00e8 rimasto stagnante; Codice Android // Example 1: get last month prices with default interval (1 day) HistoricalPricesParams params = new HistoricalPricesParams( Currency.EUR, TimeFrame.lastMonth() ); // Example 2: get prices from 16th April 2018 to 16th April 2019 with 1 week interval HistoricalPricesParams params = new HistoricalPricesParams( Currency.EUR, new TimeFrame(1523885446000L, 1563465540000L), 604800000 ); conio.exchangeService.historicalPrices(params) .asCallback(result -> result.analysis( prices -> { /* Handle HistoricalPrices */ }, error -> { /* ... */ } )); iOS // Prezzo dal 16 aprile 2019 al 16 aprile 2018 // Intervallo standard: 1 giorno let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000) // Prezzo dal 16 aprile 2019 al 16 aprile 2018 // Intervallo selezionato: 1 settimana let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000, interval: 604800000) let consumer = conio.exchangeService.historicalPrices(params: params) consumer.asCallback { result in switch result { case .success(let prices): // HistoricalPrices case .failure(let error): // Operation Error } } Recupero informazioni di trading Recupero delle informazioni riassuntive delle operazioni di compravendita eseguite dall'utente. Metodo exchangeService.tradingInfo Parametri Un oggetto di tipo TradingInfoParams , contenente: currency : di tipo Currency , la valuta sulla quale si vuole ottenere la risposta; Risposta weightedBidBalance : di tipo Decimal (iOS) / BigDecimal (Android), controvalore investito, calcolato come la media pesata del valore (in valuta fiat) degli acquisti moltiplicato per il bilancio attuale; currency : di tipo Currency , la valuta di riferimento della risposta; bidSummary : di tipo TradingSummary , contenente un riepilogo delle operazioni di acquisto; askSummary : di tipo TradingSummary , contenente un riepilogo delle operazioni di vendita; Le propriet\u00e0 di tipo TradingSummary contengono: operationsCount : di tipo intero , il numero totale di operazioni; totalFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare totale delle operazioni. Codice Android TradingInfoParams params = new TradingInfoParams(Currency.EUR); conio.exchangeService.tradingInfo(params) .asCallback(result -> result.analysis( info -> { /* Handle TradingInfo */ }, error -> { /* ... */ } )); let consumer = conio.exchangeService.tradingInfo() consumer.asCallback { result in switch result { case .success(let info): // Handle TradingInfo case .failure(let error): // Operation Error } } Recupero commissioni di trading Per recuperare le informazioni delle commissioni sulle operazioni di compravendita. Metodo exchangeService.tradingFees Parametri Un oggetto di tipo TradingFeesParams , contenente: currency : di tipo Currency , la valuta sulla quale si vuole ottenere la risposta; Risposta Un oggetto di tipo TradingFees , contenente: currency : di tipo Currency , la valuta di riferimento della risposta; bidServiceFees : di tipo List<ServiceFee> , contenente la lista delle fascie di commissioni per le operazioni di acquisto; askServiceFees : di tipo List<ServiceFee> , contenente la lista delle fascie di commissioni per le operazioni di vendita. Le propriet\u00e0 di tipo ServiceFee contengono: rangeFrom : di tipo Decimal (iOS) / BigDecimal (Android), il valore (in valuta fiat) dal quale viene applicata; @Opzionale percentage : di tipo double , la percentuale di commissione rispetto al valore del operazione, nulla se la ServiceFee rappresenta una commissione assoluta; @Opzionale fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), la commisione assuluta applicata su ogni operazione, nulla se la ServiceFee rappresenta una commissione in percentuale. Codice Android TradingFeesParams params = new TradingFeesParams(Currency.EUR); conio.exchangeService.tradingFees(params) .asCallback(result -> result.analysis( fees -> { /* Handle TradingFees */ }, error -> { /* ... */ } )); let consumer = conio.exchangeService.tradingFees() consumer.asCallback { result in switch result { case .success(let fees): // Handle TradingFees case .failure(let error): // Operation Error } } Recupero limiti di trading Per recuperare i limiti di compravendita associati ad un utente, assegnati in fase di signup tramite il campo userLevel . Metodo exchangeService.tradingLimits Risposta Un oggetto di tipo AllTradingLimits , contenente: buyLimits : di tipo TradingLimits , contenenti informazioni sui limiti di acquisto; sellLimits : di tipo TradingLimits , contenenti informazioni sui limiti di vendita. Le propriet\u00e0 di tipo TradingLimits contengono: minFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il limite minimo attualmente a disposizione; maxFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il limite massimo attualmente a disposizione; allLimits : di tipo List<Limit> , una lista di limiti, ciascuno conterr\u00e0 la rispettiva tipologia ( DAILY , MONTHLY , YEARLY ) ed il valore per ciascuno di essi; currentLimits : di tipo List<Limit> , il valore residuo per ciascuno dei limiti contenuti nell'oggetto allLimits del punto precedente. Codice Android conio.exchangeService.tradingLimits() .asCallback(result -> result.analysis( limits -> { /* Handle AllTradingLimits */ }, error -> { /* ... */ } )); iOS let consumer = conio.exchangeService.tradingLimits() consumer.asCallback { result in switch result { case .success(let fees): // Handle AllTradingLimits case .failure(let error): // Operation Error } } Acquisto di Bitcoin Per poter acquistare dei Bitcoin \u00e8 necessario effettuare due operazioni. La prima \u00e8 quella di creazione di una Bid , ovvero di una richiesta di acquisto di una determinata somma di Bitcoin ad un certo prezzo. All'interno della Bid si troveranno le WiretransferInfo che dovranno essere usate dal client per effettuare il pagamento. Infine si dovr\u00e0 utilizzare la seconda operazione verso Conio per comunicare l'avvenuto pagamento della Bid allegando anche una BidCryptoRequest , generata client side, per testimoniare la legittimit\u00e0 dell'operazione. Creazione della Bid Una Bid si crea specificando la valuta che si intende utilizzare per la transazione e l'importo, o in satoshi o in valuta corrente. Ad esempio, sar\u00e0 quindi possibile richiedere una Bid per l'acquisto di 150\u20ac di Bitcoin o una Bid per l'acquisto di 100.000.000 satoshi. Una volta inviata la richiesta, si otterr\u00e0 una CreatedBid contenente, tra le altre informazioni un bidId . Con questo identificativo sar\u00e0 possibile aggiornare la richiesta di Bid per rimandarne la scadenza e per ottenere le informazioni sul tasso di cambio pi\u00f9 aggiornate. Questo scenario \u00e8 utile nei casi in cui tra la richiesta della Bid e l'effettiva azione dell'utente passi del tempo che renderebbe il tasso di cambio obsoleto. Metodo exchangeService.createOrRefreshBid Parametri Un oggetto di tipo CreateOrRefreshBidParams , costruibile tramite i metodi factory CreateOrRefreshBidParams.fromFiat o CreateOrRefreshBidParams.fromCrypto che richiedono: currency : di tipo Currency , la valuta dell'operazione; amount : di tipo long per .fromCrypto o Decimal (iOS) / BigDecimal (Android) per .fromFiat , l'ammontare, a seconda del metodo usato, in satoshi o nella valuta scelta che si vuole acquistare; @Opzionale bidId : di tipo String , l'id della bid, da valorizzare solo in caso di refresh della bid stessa. Risposta Un oggetto di tipo CreatedBid che contiene: id : di tipo String , l'id utile al refresh o alla finalizzazione della bid; currency : di tipo Currency , la valuta dell'operazione; cryptoAmount : di tipo long , l'ammontare in satoshi della richiesta d'acquisto; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto al netto delle commissioni; grossFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto comprensivo delle commissioni; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni di servizio per la transazione, espresse nella currency di riferimento expiration : di tipo long , il timestamp di scadenza della richiesta di pagamento. Se la bid scade sar\u00e0 necessario aggiornarla per proseguire wireTransferInfo : di tipo WireTransferInfo , le informazioni necessarie per procedere al pagamento della Bid tramite bonifico. Codice Android // Example 1: \u20ac200 bid CreateOrRefreshBidParams params = CreateOrRefreshBidParams.fromFiat(Currency.EUR, 20000); // Example 2: 1.000.000.000 satoshi bid CreateOrRefreshBidParams params = CreateOrRefreshBidParams.fromCrypto(Currency.EUR, 1000000000); conio.exchangeService.createOrRefreshBid(params) .asCallback(result -> result.analysis( bid -> { /* Handle CreatedBid */ }, error -> { /* ... */ } )); iOS // Richiesta d'acquisto per 50\u20ac let params = CreateOrRefreshBidParams(currency: .eur, fiatAmount: 50.0) // Richiesta d'acquisto per 1.000.000 satoshi let params = CreateOrRefreshBidParams(currency: .eur, satoshi: 1000000) // Aggiornamento di una richiesta d'acquisto per 100\u20ac let params = CreateOrRefreshBidParams(bidID: \"bididentifier\", currency: .eur, fiatAmount: 100.0) let consumer = conio.exchangeService.createOrRefreshBid(params: params) consumer.asCallback { result in switch result { case .success(let bid): // Handle CreatedBid case .failure(let error): // Operation Error } } Utilizzo della Bid (pagamento) Una volta effettuato il pagamento tramite bonifico si dovr\u00e0 usare l'operazione purchase per comunicare a Conio l'avvenuto pagamento. Questa operazione richieder\u00e0 una BidCryptoRequest . Metodo exchangeService.purchase Parametri Un oggetto di tipo PurchaseParams contenente: bidId : d tipo String , l'id della Bid da pagare cryptoRequest : di tipo BidCryptoRequest , configurabile come descritto nell'apposita sezione Risposta Un oggetto di tipo Success , che conferma l'avvenuta operazione. Errori INVALID_CRYPTO_PROOF La crypto proof non \u00e8 valida INVALID_PAYMENT_METHOD Il metodo di pagamento non \u00e8 valido UNSUPPORTED_PAYMENT_METHOD Il metodo di pagamento non \u00e8 supportato TRADING_LIMITS_EXCEEDED La bid viola i limiti massimi di acquisto dell'utente TRADE_EXPIRED La bid \u00e8 scaduta BID_ALREADY_PAID La bid \u00e8 gi\u00e0 stata pagata BID_NOT_YET_PAID La bid non \u00e8 ancora stata pagata UNRECOVERABLE_BID La bid \u00e8 in errore FIAT_AMOUNT_TOO_LOW L'importo in Fiat \u00e8 inferiore al limite minimo Codice Android PurchaseParams params = new PurchaseParams(\"bidId\", bidCryptoRequest); conio.exchangeService.purchase(params) .asCallback(result -> result.analysis( success -> { /* Handle Success */ }, error -> { /* ... */ } )); iOS let params = PurchaseParams(bidId: \"bidId\", cryptoRequest: bidCryptoRequest) let consumer = conio.exchangeService.purchase(params: params) consumer.asCallback { result in switch result { case .success: // Handle Success case .failure(let error): // Operation Error } } Vendita di Bitcoin Per poter vendere dei Bitcoin \u00e8 necessario effettuare due operazioni. La prima \u00e8 quella di creazione di una Ask , ovvero di una richiesta di vendita di una determinata somma di Bitcoin ad un certo prezzo. Si procede poi con il pagamento di tale Ask , passando l' askId e allegando anche una AskCryptoRequest , generata client side, per testimoniare la legittimit\u00e0 dell'operazione. L'SDK firmer\u00e0 la transazione che sposter\u00e0 i Bitcoin dal wallet dell'utente, restituendo alla fine l'id della Ask completata. Creazione della Ask Per richiedere una Ask si dovr\u00e0 procedere analogamente a quanto visto per la Bid. Sar\u00e0 quindi possibile richiedere una CreatedAsk per la vendita di 150\u20ac o una per la vendita di 100.000.000 satoshi. Una volta inviata la richiesta, si otterr\u00e0 una CreatedAsk contenente, tra le altre informazioni un askId . Con questo identificativo sar\u00e0 possibile aggiornare la richiesta di Ask per rimandarne la scadenza e per ottenere le informazioni sul tasso di cambio pi\u00f9 aggiornate. Questo scenario \u00e8 utile nei casi in cui tra la richiesta della Ask e l'effettiva azione dell'utente passi del tempo che renderebbe il tasso di cambio obsoleto. Metodo exchangeService.createOrRefreshAsk Parametri Un oggetto di tipo CreateOrRefreshAskParams , costruibile tramite i metodi factory CreateOrRefreshAskParams.fromFiat o CreateOrRefreshAskParams.fromCrypto che richiedono: currency : di tipo Currency , la valuta dell'operazione; amount : di tipo long per .fromCrypto o Decimal (iOS) / BigDecimal (Android) per .fromFiat , l'ammontare, a seconda del metodo usato, in satoshi o nella valuta scelta che si vuole vendere; @Opzionale askId : di tipo String , l'id della ask, da valorizzare solo in caso di refresh della ask stessa. Risposta Un oggetto di tipo CreatedAsk che contiene: askId : di tipo String , l'id utile al refresh o alla finalizzazione della ask; currency : di tipo Currency , la valuta dell'operazione; cryptoAmount : di tipo long , l'ammontare in satoshi della richiesta d'acquisto fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni di servizio per la transazione, espresse nella currency di riferimento; miningFee : di tipo long , le commissioni per scrivere la transazione in blockchain, espresse in satoshi; expiration : di tipo long , lo Unix Timestamp di scadenza della richiesta di pagamento. Se la bid scade sar\u00e0 necessario aggiornarla per proseguire Errori TRADING_LIMITS_EXCEEDED L'utente ha 0 Eur di limiti residui NOT_ENOUGH_BTC_AMOUNT solo se non ha btc L'utente non ha alcun bitcoin NO_SUCH_SELLER Errore interno del sottosistema di vendita NO_SUCH_WALLET Errore interno del sottosistema di wallet Android // Example 1: \u20ac200 ask CreateOrRefreshAskParams params = CreateOrRefreshAskParams.fromFiat(Currency.EUR, BigDecimal(\"200\")); // Example 2: 1.000.000.000 satoshi ask CreateOrRefreshAskParams params = CreateOrRefreshAskParams.fromCrypto(Currency.EUR, 1000000000); conio.exchangeService.createOrRefreshAsk(params) .asCallback(result -> result.analysis( ask -> { /* Handle CreatedAsk */ }, error -> { /* ... */ } )); iOS // Richiesta di vendita per 50\u20ac let params = CreateOrRefreshAskParams(currency: .eur, fiatAmount: 50.0) // Richiesta di vendita per 100000000 satoshi let params = CreateOrRefreshAskParams(currency: .eur, satoshi: 100000000) // Aggiornamento del valore di una Ask esistente let params = CreateOrRefreshAskParams(askID: \"id\", currency: .eur, fiatAmount: 100.0) conio.exchangeService.createOrRefreshAsk(params: params).asCallback { result in switch result { case .success(let createdAsk): // CreatedBid case .failure(let error): // Operation Error } } Utilizzo della Ask Ottenuta la Ask da utilizzare \u00e8 possibile procedere con la finalizzazione della vendita. Per effettuare questa operazione bisogner\u00e0 passare l'ID della CreatedAsk alla Sell operation, insieme alla AskCryptoRequest . Metodo exchangeService.sell Parametri Un oggetto di tipo SellParams contenente: askId : di tipo String , l'id della Ask cryptoRequest : di tipo AskCryptoRequest , configurabile come descritto nell'apposita sezione Risposta Un oggetto di tipo Success che conferma l'avvenuta operazione. Errori TRADING_LIMITS_EXCEEDED La ask viola i limiti massimi di acquisto dell'utente TRADE_EXPIRED La ask \u00e8 scaduta UNRECOVERABLE_ASK La ask \u00e8 in errore ASK_ALREADY_PAID La ask \u00e8 gi\u00e0 stata pagata NOT_ENOUGH_BTC_AMOUNT_E Bitcoin disponibili non sufficienti DUST_ASK Importo in Bitcoin troppo piccolo FIAT_AMOUNT_TOO_LOW Importo in Eur troppo basso Codice Android SellParams params = new SellParams(\"askId\", askCryptoRequest); conio.exchangeService.sell(params) .asCallback(result -> result.analysis( success -> { /* Handle Success */ }, error -> { /* ... */ } )); iOS let params = SellParams(askID: askID) conio.exchangeService.createOrRefreshAsk(params: params).asCallback { result in switch result { case .success: // Handle Succes case .failure(let error): // Operation Error } }","title":"exchangeOperations"},{"location":"exchange/Exchange/#operazioni-sul-mercato","text":"","title":"Operazioni sul mercato"},{"location":"exchange/Exchange/#prezzo-attuale-del-bitcoin","text":"\u00c8 possibile recuperare il miglior prezzo di acquisto e di vendita attuale del bitcoin, specificando la valuta nel quale lo si vuole ottenere. Inoltre, l'SDK offre la possibilit\u00e0 di convertire un ammontare in bitcoin nella valuta specificata.","title":"Prezzo attuale del Bitcoin"},{"location":"exchange/Exchange/#metodo","text":"exchangeService.currentPrice","title":"Metodo"},{"location":"exchange/Exchange/#parametri","text":"Un oggetto di tipo CurrentPriceParams contenente: currency : di tipo Currency , la valuta in cui si vuole ottenere il prezzo; @Opzionale cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) che si vuole convertire nella valuta indicata.","title":"Parametri"},{"location":"exchange/Exchange/#risposta","text":"Un CurrentPrice contenente: buyFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il prezzo di acquisto, calcolato nella valuta indicata tramite il campo currency ; sellFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il prezzo di vendita, calcolato nella valuta indicata tramite il campo currency .","title":"Risposta"},{"location":"exchange/Exchange/#codice","text":"","title":"Codice"},{"location":"exchange/Exchange/#android","text":"// Example 1: get current price CurrentPriceParams params = new CurrentPriceParams(Currency.EUR); // Example 2: get current price of a specified amount CurrentPriceParams params = new CurrentPriceParams(Currency.EUR, 100000000); conio.exchangeService.currentPrice(params) .asCallback(result -> result.analysis( currentPrice -> { /* Handle CurrentPrice */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios","text":"// Recupero del prezzo attuale let params = CurrentPriceParams(currency: .eur) // Conversione di 50.000.000 satoshi (0,5 BTC) in euro let params = CurrentPriceParams(currency: .eur, satoshiAmount: 50_000_000) let consumer = conio.exchangeService.currentPrice(params: params) consumer.asCallback { result in switch result { case .success(let prices): // CurrentPrice case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#prezzo-storico-del-bitcoin","text":"\u00c8 possibile recuperare il prezzo storico del Bitcoin selezionando una finestra temporale di riferimento.","title":"Prezzo storico del Bitcoin"},{"location":"exchange/Exchange/#metodo_1","text":"exchangeService.historicalPrices","title":"Metodo"},{"location":"exchange/Exchange/#parametri_1","text":"Un oggetto di tipo HistoricalPricesParams contenente: currency : di tipo Currency , la valuta in cui si vuole ottenere il prezzo; timeFrame : di tipo TimeFrame , la finestra temporale di riferimento; @Default(24h) interval : di tipo long , l'intervallo che si vuole porre tra i prezzi restituiti;","title":"Parametri"},{"location":"exchange/Exchange/#risposta_1","text":"Un HistoricalPrices contenente: prices : di tipo List<PricePoint> , la lista dei prezzi del bitcoin nella finestra temporale specificata; analytics : di tipo PriceAnalytics , contenente: deltaFiat : di tipo Decimal (iOS) / BigDecimal (Android), la variazione in valuta del prezzo del Bitcoin dall'inizio del periodo di riferimento; deltaPercentage : la variazione in percentuale del prezzo del Bitcoin dall'inizio del periodo di riferimento; trend : di tipo PriceTrend , un enumerato che rappresenta se il prezzo del Bitcoin, dall'inizio del periodo di riferimento, \u00e8 cresciuto, \u00e8 diminuito o \u00e8 rimasto stagnante;","title":"Risposta"},{"location":"exchange/Exchange/#codice_1","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_1","text":"// Example 1: get last month prices with default interval (1 day) HistoricalPricesParams params = new HistoricalPricesParams( Currency.EUR, TimeFrame.lastMonth() ); // Example 2: get prices from 16th April 2018 to 16th April 2019 with 1 week interval HistoricalPricesParams params = new HistoricalPricesParams( Currency.EUR, new TimeFrame(1523885446000L, 1563465540000L), 604800000 ); conio.exchangeService.historicalPrices(params) .asCallback(result -> result.analysis( prices -> { /* Handle HistoricalPrices */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_1","text":"// Prezzo dal 16 aprile 2019 al 16 aprile 2018 // Intervallo standard: 1 giorno let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000) // Prezzo dal 16 aprile 2019 al 16 aprile 2018 // Intervallo selezionato: 1 settimana let params = HistoricalPriceParams(currency: .eur, startTimestamp: 1523885446000, endTimestamp: 1563465540000, interval: 604800000) let consumer = conio.exchangeService.historicalPrices(params: params) consumer.asCallback { result in switch result { case .success(let prices): // HistoricalPrices case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#recupero-informazioni-di-trading","text":"Recupero delle informazioni riassuntive delle operazioni di compravendita eseguite dall'utente.","title":"Recupero informazioni di trading"},{"location":"exchange/Exchange/#metodo_2","text":"exchangeService.tradingInfo","title":"Metodo"},{"location":"exchange/Exchange/#parametri_2","text":"Un oggetto di tipo TradingInfoParams , contenente: currency : di tipo Currency , la valuta sulla quale si vuole ottenere la risposta;","title":"Parametri"},{"location":"exchange/Exchange/#risposta_2","text":"weightedBidBalance : di tipo Decimal (iOS) / BigDecimal (Android), controvalore investito, calcolato come la media pesata del valore (in valuta fiat) degli acquisti moltiplicato per il bilancio attuale; currency : di tipo Currency , la valuta di riferimento della risposta; bidSummary : di tipo TradingSummary , contenente un riepilogo delle operazioni di acquisto; askSummary : di tipo TradingSummary , contenente un riepilogo delle operazioni di vendita; Le propriet\u00e0 di tipo TradingSummary contengono: operationsCount : di tipo intero , il numero totale di operazioni; totalFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare totale delle operazioni.","title":"Risposta"},{"location":"exchange/Exchange/#codice_2","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_2","text":"TradingInfoParams params = new TradingInfoParams(Currency.EUR); conio.exchangeService.tradingInfo(params) .asCallback(result -> result.analysis( info -> { /* Handle TradingInfo */ }, error -> { /* ... */ } )); let consumer = conio.exchangeService.tradingInfo() consumer.asCallback { result in switch result { case .success(let info): // Handle TradingInfo case .failure(let error): // Operation Error } }","title":"Android"},{"location":"exchange/Exchange/#recupero-commissioni-di-trading","text":"Per recuperare le informazioni delle commissioni sulle operazioni di compravendita.","title":"Recupero commissioni di trading"},{"location":"exchange/Exchange/#metodo_3","text":"exchangeService.tradingFees","title":"Metodo"},{"location":"exchange/Exchange/#parametri_3","text":"Un oggetto di tipo TradingFeesParams , contenente: currency : di tipo Currency , la valuta sulla quale si vuole ottenere la risposta;","title":"Parametri"},{"location":"exchange/Exchange/#risposta_3","text":"Un oggetto di tipo TradingFees , contenente: currency : di tipo Currency , la valuta di riferimento della risposta; bidServiceFees : di tipo List<ServiceFee> , contenente la lista delle fascie di commissioni per le operazioni di acquisto; askServiceFees : di tipo List<ServiceFee> , contenente la lista delle fascie di commissioni per le operazioni di vendita. Le propriet\u00e0 di tipo ServiceFee contengono: rangeFrom : di tipo Decimal (iOS) / BigDecimal (Android), il valore (in valuta fiat) dal quale viene applicata; @Opzionale percentage : di tipo double , la percentuale di commissione rispetto al valore del operazione, nulla se la ServiceFee rappresenta una commissione assoluta; @Opzionale fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), la commisione assuluta applicata su ogni operazione, nulla se la ServiceFee rappresenta una commissione in percentuale.","title":"Risposta"},{"location":"exchange/Exchange/#codice_3","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_3","text":"TradingFeesParams params = new TradingFeesParams(Currency.EUR); conio.exchangeService.tradingFees(params) .asCallback(result -> result.analysis( fees -> { /* Handle TradingFees */ }, error -> { /* ... */ } )); let consumer = conio.exchangeService.tradingFees() consumer.asCallback { result in switch result { case .success(let fees): // Handle TradingFees case .failure(let error): // Operation Error } }","title":"Android"},{"location":"exchange/Exchange/#recupero-limiti-di-trading","text":"Per recuperare i limiti di compravendita associati ad un utente, assegnati in fase di signup tramite il campo userLevel .","title":"Recupero limiti di trading"},{"location":"exchange/Exchange/#metodo_4","text":"exchangeService.tradingLimits","title":"Metodo"},{"location":"exchange/Exchange/#risposta_4","text":"Un oggetto di tipo AllTradingLimits , contenente: buyLimits : di tipo TradingLimits , contenenti informazioni sui limiti di acquisto; sellLimits : di tipo TradingLimits , contenenti informazioni sui limiti di vendita. Le propriet\u00e0 di tipo TradingLimits contengono: minFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il limite minimo attualmente a disposizione; maxFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il limite massimo attualmente a disposizione; allLimits : di tipo List<Limit> , una lista di limiti, ciascuno conterr\u00e0 la rispettiva tipologia ( DAILY , MONTHLY , YEARLY ) ed il valore per ciascuno di essi; currentLimits : di tipo List<Limit> , il valore residuo per ciascuno dei limiti contenuti nell'oggetto allLimits del punto precedente.","title":"Risposta"},{"location":"exchange/Exchange/#codice_4","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_4","text":"conio.exchangeService.tradingLimits() .asCallback(result -> result.analysis( limits -> { /* Handle AllTradingLimits */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_2","text":"let consumer = conio.exchangeService.tradingLimits() consumer.asCallback { result in switch result { case .success(let fees): // Handle AllTradingLimits case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#acquisto-di-bitcoin","text":"Per poter acquistare dei Bitcoin \u00e8 necessario effettuare due operazioni. La prima \u00e8 quella di creazione di una Bid , ovvero di una richiesta di acquisto di una determinata somma di Bitcoin ad un certo prezzo. All'interno della Bid si troveranno le WiretransferInfo che dovranno essere usate dal client per effettuare il pagamento. Infine si dovr\u00e0 utilizzare la seconda operazione verso Conio per comunicare l'avvenuto pagamento della Bid allegando anche una BidCryptoRequest , generata client side, per testimoniare la legittimit\u00e0 dell'operazione.","title":"Acquisto di Bitcoin"},{"location":"exchange/Exchange/#creazione-della-bid","text":"Una Bid si crea specificando la valuta che si intende utilizzare per la transazione e l'importo, o in satoshi o in valuta corrente. Ad esempio, sar\u00e0 quindi possibile richiedere una Bid per l'acquisto di 150\u20ac di Bitcoin o una Bid per l'acquisto di 100.000.000 satoshi. Una volta inviata la richiesta, si otterr\u00e0 una CreatedBid contenente, tra le altre informazioni un bidId . Con questo identificativo sar\u00e0 possibile aggiornare la richiesta di Bid per rimandarne la scadenza e per ottenere le informazioni sul tasso di cambio pi\u00f9 aggiornate. Questo scenario \u00e8 utile nei casi in cui tra la richiesta della Bid e l'effettiva azione dell'utente passi del tempo che renderebbe il tasso di cambio obsoleto.","title":"Creazione della Bid"},{"location":"exchange/Exchange/#metodo_5","text":"exchangeService.createOrRefreshBid","title":"Metodo"},{"location":"exchange/Exchange/#parametri_4","text":"Un oggetto di tipo CreateOrRefreshBidParams , costruibile tramite i metodi factory CreateOrRefreshBidParams.fromFiat o CreateOrRefreshBidParams.fromCrypto che richiedono: currency : di tipo Currency , la valuta dell'operazione; amount : di tipo long per .fromCrypto o Decimal (iOS) / BigDecimal (Android) per .fromFiat , l'ammontare, a seconda del metodo usato, in satoshi o nella valuta scelta che si vuole acquistare; @Opzionale bidId : di tipo String , l'id della bid, da valorizzare solo in caso di refresh della bid stessa.","title":"Parametri"},{"location":"exchange/Exchange/#risposta_5","text":"Un oggetto di tipo CreatedBid che contiene: id : di tipo String , l'id utile al refresh o alla finalizzazione della bid; currency : di tipo Currency , la valuta dell'operazione; cryptoAmount : di tipo long , l'ammontare in satoshi della richiesta d'acquisto; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto al netto delle commissioni; grossFiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto comprensivo delle commissioni; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni di servizio per la transazione, espresse nella currency di riferimento expiration : di tipo long , il timestamp di scadenza della richiesta di pagamento. Se la bid scade sar\u00e0 necessario aggiornarla per proseguire wireTransferInfo : di tipo WireTransferInfo , le informazioni necessarie per procedere al pagamento della Bid tramite bonifico.","title":"Risposta"},{"location":"exchange/Exchange/#codice_5","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_5","text":"// Example 1: \u20ac200 bid CreateOrRefreshBidParams params = CreateOrRefreshBidParams.fromFiat(Currency.EUR, 20000); // Example 2: 1.000.000.000 satoshi bid CreateOrRefreshBidParams params = CreateOrRefreshBidParams.fromCrypto(Currency.EUR, 1000000000); conio.exchangeService.createOrRefreshBid(params) .asCallback(result -> result.analysis( bid -> { /* Handle CreatedBid */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_3","text":"// Richiesta d'acquisto per 50\u20ac let params = CreateOrRefreshBidParams(currency: .eur, fiatAmount: 50.0) // Richiesta d'acquisto per 1.000.000 satoshi let params = CreateOrRefreshBidParams(currency: .eur, satoshi: 1000000) // Aggiornamento di una richiesta d'acquisto per 100\u20ac let params = CreateOrRefreshBidParams(bidID: \"bididentifier\", currency: .eur, fiatAmount: 100.0) let consumer = conio.exchangeService.createOrRefreshBid(params: params) consumer.asCallback { result in switch result { case .success(let bid): // Handle CreatedBid case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#utilizzo-della-bid-pagamento","text":"Una volta effettuato il pagamento tramite bonifico si dovr\u00e0 usare l'operazione purchase per comunicare a Conio l'avvenuto pagamento. Questa operazione richieder\u00e0 una BidCryptoRequest .","title":"Utilizzo della Bid (pagamento)"},{"location":"exchange/Exchange/#metodo_6","text":"exchangeService.purchase","title":"Metodo"},{"location":"exchange/Exchange/#parametri_5","text":"Un oggetto di tipo PurchaseParams contenente: bidId : d tipo String , l'id della Bid da pagare cryptoRequest : di tipo BidCryptoRequest , configurabile come descritto nell'apposita sezione","title":"Parametri"},{"location":"exchange/Exchange/#risposta_6","text":"Un oggetto di tipo Success , che conferma l'avvenuta operazione.","title":"Risposta"},{"location":"exchange/Exchange/#errori","text":"INVALID_CRYPTO_PROOF La crypto proof non \u00e8 valida INVALID_PAYMENT_METHOD Il metodo di pagamento non \u00e8 valido UNSUPPORTED_PAYMENT_METHOD Il metodo di pagamento non \u00e8 supportato TRADING_LIMITS_EXCEEDED La bid viola i limiti massimi di acquisto dell'utente TRADE_EXPIRED La bid \u00e8 scaduta BID_ALREADY_PAID La bid \u00e8 gi\u00e0 stata pagata BID_NOT_YET_PAID La bid non \u00e8 ancora stata pagata UNRECOVERABLE_BID La bid \u00e8 in errore FIAT_AMOUNT_TOO_LOW L'importo in Fiat \u00e8 inferiore al limite minimo","title":"Errori"},{"location":"exchange/Exchange/#codice_6","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_6","text":"PurchaseParams params = new PurchaseParams(\"bidId\", bidCryptoRequest); conio.exchangeService.purchase(params) .asCallback(result -> result.analysis( success -> { /* Handle Success */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_4","text":"let params = PurchaseParams(bidId: \"bidId\", cryptoRequest: bidCryptoRequest) let consumer = conio.exchangeService.purchase(params: params) consumer.asCallback { result in switch result { case .success: // Handle Success case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#vendita-di-bitcoin","text":"Per poter vendere dei Bitcoin \u00e8 necessario effettuare due operazioni. La prima \u00e8 quella di creazione di una Ask , ovvero di una richiesta di vendita di una determinata somma di Bitcoin ad un certo prezzo. Si procede poi con il pagamento di tale Ask , passando l' askId e allegando anche una AskCryptoRequest , generata client side, per testimoniare la legittimit\u00e0 dell'operazione. L'SDK firmer\u00e0 la transazione che sposter\u00e0 i Bitcoin dal wallet dell'utente, restituendo alla fine l'id della Ask completata.","title":"Vendita di Bitcoin"},{"location":"exchange/Exchange/#creazione-della-ask","text":"Per richiedere una Ask si dovr\u00e0 procedere analogamente a quanto visto per la Bid. Sar\u00e0 quindi possibile richiedere una CreatedAsk per la vendita di 150\u20ac o una per la vendita di 100.000.000 satoshi. Una volta inviata la richiesta, si otterr\u00e0 una CreatedAsk contenente, tra le altre informazioni un askId . Con questo identificativo sar\u00e0 possibile aggiornare la richiesta di Ask per rimandarne la scadenza e per ottenere le informazioni sul tasso di cambio pi\u00f9 aggiornate. Questo scenario \u00e8 utile nei casi in cui tra la richiesta della Ask e l'effettiva azione dell'utente passi del tempo che renderebbe il tasso di cambio obsoleto.","title":"Creazione della Ask"},{"location":"exchange/Exchange/#metodo_7","text":"exchangeService.createOrRefreshAsk","title":"Metodo"},{"location":"exchange/Exchange/#parametri_6","text":"Un oggetto di tipo CreateOrRefreshAskParams , costruibile tramite i metodi factory CreateOrRefreshAskParams.fromFiat o CreateOrRefreshAskParams.fromCrypto che richiedono: currency : di tipo Currency , la valuta dell'operazione; amount : di tipo long per .fromCrypto o Decimal (iOS) / BigDecimal (Android) per .fromFiat , l'ammontare, a seconda del metodo usato, in satoshi o nella valuta scelta che si vuole vendere; @Opzionale askId : di tipo String , l'id della ask, da valorizzare solo in caso di refresh della ask stessa.","title":"Parametri"},{"location":"exchange/Exchange/#risposta_7","text":"Un oggetto di tipo CreatedAsk che contiene: askId : di tipo String , l'id utile al refresh o alla finalizzazione della ask; currency : di tipo Currency , la valuta dell'operazione; cryptoAmount : di tipo long , l'ammontare in satoshi della richiesta d'acquisto fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), l'ammontare in valuta corrente della richiesta d'acquisto; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni di servizio per la transazione, espresse nella currency di riferimento; miningFee : di tipo long , le commissioni per scrivere la transazione in blockchain, espresse in satoshi; expiration : di tipo long , lo Unix Timestamp di scadenza della richiesta di pagamento. Se la bid scade sar\u00e0 necessario aggiornarla per proseguire","title":"Risposta"},{"location":"exchange/Exchange/#errori_1","text":"TRADING_LIMITS_EXCEEDED L'utente ha 0 Eur di limiti residui NOT_ENOUGH_BTC_AMOUNT solo se non ha btc L'utente non ha alcun bitcoin NO_SUCH_SELLER Errore interno del sottosistema di vendita NO_SUCH_WALLET Errore interno del sottosistema di wallet","title":"Errori"},{"location":"exchange/Exchange/#android_7","text":"// Example 1: \u20ac200 ask CreateOrRefreshAskParams params = CreateOrRefreshAskParams.fromFiat(Currency.EUR, BigDecimal(\"200\")); // Example 2: 1.000.000.000 satoshi ask CreateOrRefreshAskParams params = CreateOrRefreshAskParams.fromCrypto(Currency.EUR, 1000000000); conio.exchangeService.createOrRefreshAsk(params) .asCallback(result -> result.analysis( ask -> { /* Handle CreatedAsk */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_5","text":"// Richiesta di vendita per 50\u20ac let params = CreateOrRefreshAskParams(currency: .eur, fiatAmount: 50.0) // Richiesta di vendita per 100000000 satoshi let params = CreateOrRefreshAskParams(currency: .eur, satoshi: 100000000) // Aggiornamento del valore di una Ask esistente let params = CreateOrRefreshAskParams(askID: \"id\", currency: .eur, fiatAmount: 100.0) conio.exchangeService.createOrRefreshAsk(params: params).asCallback { result in switch result { case .success(let createdAsk): // CreatedBid case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"exchange/Exchange/#utilizzo-della-ask","text":"Ottenuta la Ask da utilizzare \u00e8 possibile procedere con la finalizzazione della vendita. Per effettuare questa operazione bisogner\u00e0 passare l'ID della CreatedAsk alla Sell operation, insieme alla AskCryptoRequest .","title":"Utilizzo della Ask"},{"location":"exchange/Exchange/#metodo_8","text":"exchangeService.sell","title":"Metodo"},{"location":"exchange/Exchange/#parametri_7","text":"Un oggetto di tipo SellParams contenente: askId : di tipo String , l'id della Ask cryptoRequest : di tipo AskCryptoRequest , configurabile come descritto nell'apposita sezione","title":"Parametri"},{"location":"exchange/Exchange/#risposta_8","text":"Un oggetto di tipo Success che conferma l'avvenuta operazione.","title":"Risposta"},{"location":"exchange/Exchange/#errori_2","text":"TRADING_LIMITS_EXCEEDED La ask viola i limiti massimi di acquisto dell'utente TRADE_EXPIRED La ask \u00e8 scaduta UNRECOVERABLE_ASK La ask \u00e8 in errore ASK_ALREADY_PAID La ask \u00e8 gi\u00e0 stata pagata NOT_ENOUGH_BTC_AMOUNT_E Bitcoin disponibili non sufficienti DUST_ASK Importo in Bitcoin troppo piccolo FIAT_AMOUNT_TOO_LOW Importo in Eur troppo basso","title":"Errori"},{"location":"exchange/Exchange/#codice_7","text":"","title":"Codice"},{"location":"exchange/Exchange/#android_8","text":"SellParams params = new SellParams(\"askId\", askCryptoRequest); conio.exchangeService.sell(params) .asCallback(result -> result.analysis( success -> { /* Handle Success */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"exchange/Exchange/#ios_6","text":"let params = SellParams(askID: askID) conio.exchangeService.createOrRefreshAsk(params: params).asCallback { result in switch result { case .success: // Handle Succes case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"installation/Android.en/","text":"Italiano Install on Android You can install the SDK using Artifactory as Maven repository. To authenticate you have to put your credentials in the app gradle.properties file: gradle.properties artifactory_user={username} artifactory_password={password} Then in the app build.gradle file add the repository address: app/build.gradle repositories { ... maven { url \"https://d314astu88ufzo.cloudfront.net/artifactory/gradle-release-local\" credentials(PasswordCredentials) { username \"${artifactory_user}\" password \"${artifactory_password}\" } } } Finally add Conio SDK as app dependency: app/build.gradle dependencies { ... implementation 'com.conio:sdk2:[VERSION]' } Then just sync Gradle files.","title":"Android"},{"location":"installation/Android.en/#install-on-android","text":"You can install the SDK using Artifactory as Maven repository. To authenticate you have to put your credentials in the app gradle.properties file:","title":"Install on Android"},{"location":"installation/Android.en/#gradleproperties","text":"artifactory_user={username} artifactory_password={password} Then in the app build.gradle file add the repository address:","title":"gradle.properties"},{"location":"installation/Android.en/#appbuildgradle","text":"repositories { ... maven { url \"https://d314astu88ufzo.cloudfront.net/artifactory/gradle-release-local\" credentials(PasswordCredentials) { username \"${artifactory_user}\" password \"${artifactory_password}\" } } } Finally add Conio SDK as app dependency:","title":"app/build.gradle"},{"location":"installation/Android.en/#appbuildgradle_1","text":"dependencies { ... implementation 'com.conio:sdk2:[VERSION]' } Then just sync Gradle files.","title":"app/build.gradle"},{"location":"installation/Android/","text":"English Installazione su Android L'SDK si installa utilizzando il repository Maven di Artifactory. Per potersi autenticare al repository \u00e8 necessario configurare le credenziali nel file gradle.properties come segue: gradle.properties artifactory_user={username} artifactory_password={password} A questo punto sar\u00e0 possibile aggiungere l'indirizzo del repository nel build.gradle dell'applicazione: app/build.gradle repositories { ... maven { url \"https://artifactory.conio.com/artifactory/gradle-release-local\" credentials(PasswordCredentials) { username \"${artifactory_user}\" password \"${artifactory_password}\" } } } Dopo aver specificato l'indirizzo del repository dal quale verranno sincronizzati gli artefatti sar\u00e0 possibile aggiungere il Conio SDK come dipendeza dell'applicazione: app/build.gradle dependencies { ... implementation 'com.conio:sdk2:[VERSION]' } Sincronizzando il progetto con Gradle sar\u00e0 possibile utilizzare l'SDK.","title":"Android"},{"location":"installation/Android/#installazione-su-android","text":"L'SDK si installa utilizzando il repository Maven di Artifactory. Per potersi autenticare al repository \u00e8 necessario configurare le credenziali nel file gradle.properties come segue:","title":"Installazione su Android"},{"location":"installation/Android/#gradleproperties","text":"artifactory_user={username} artifactory_password={password} A questo punto sar\u00e0 possibile aggiungere l'indirizzo del repository nel build.gradle dell'applicazione:","title":"gradle.properties"},{"location":"installation/Android/#appbuildgradle","text":"repositories { ... maven { url \"https://artifactory.conio.com/artifactory/gradle-release-local\" credentials(PasswordCredentials) { username \"${artifactory_user}\" password \"${artifactory_password}\" } } } Dopo aver specificato l'indirizzo del repository dal quale verranno sincronizzati gli artefatti sar\u00e0 possibile aggiungere il Conio SDK come dipendeza dell'applicazione:","title":"app/build.gradle"},{"location":"installation/Android/#appbuildgradle_1","text":"dependencies { ... implementation 'com.conio:sdk2:[VERSION]' } Sincronizzando il progetto con Gradle sar\u00e0 possibile utilizzare l'SDK.","title":"app/build.gradle"},{"location":"installation/iOS.en/","text":"Italiano Installation Prerequisites iOS 10+ Autoconf installed Automake installed Libtool installed Consider using MacOS package manager Brew to install Autoconf , Automake e Libtool . # Install Brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # Install Autoconf, Automake and Libtool brew install autoconf automake libtool Cocoapods install Add this line to your podfile: # The ConioSDK Core pod 'ConioSDK', :git => 'git@bitbucket.org:squadrone/conio-swift-sdk.git', :branch => 'master' # BitcoinKit for encryption purposes pod 'BitcoinKit', :git => 'https://github.com/Conio/BitcoinKit.git', :branch => 'keyconvert' Then use the command: pod install --- Troubleshooting If you get the following error: autoreconf: failed to run aclocal: No such file or directory Try the following command: brew install autoconf && brew install automake . If you get the following error: Can't exec \"/opt/local/bin/aclocal\": No such file or directory Uninstall MacPorts with: sudo port -fp uninstall --follow-dependents installed","title":"iOS"},{"location":"installation/iOS.en/#installation","text":"","title":"Installation"},{"location":"installation/iOS.en/#prerequisites","text":"iOS 10+ Autoconf installed Automake installed Libtool installed Consider using MacOS package manager Brew to install Autoconf , Automake e Libtool . # Install Brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # Install Autoconf, Automake and Libtool brew install autoconf automake libtool","title":"Prerequisites"},{"location":"installation/iOS.en/#cocoapods-install","text":"Add this line to your podfile: # The ConioSDK Core pod 'ConioSDK', :git => 'git@bitbucket.org:squadrone/conio-swift-sdk.git', :branch => 'master' # BitcoinKit for encryption purposes pod 'BitcoinKit', :git => 'https://github.com/Conio/BitcoinKit.git', :branch => 'keyconvert' Then use the command: pod install","title":"Cocoapods install"},{"location":"installation/iOS.en/#-","text":"","title":"---"},{"location":"installation/iOS.en/#troubleshooting","text":"If you get the following error: autoreconf: failed to run aclocal: No such file or directory Try the following command: brew install autoconf && brew install automake . If you get the following error: Can't exec \"/opt/local/bin/aclocal\": No such file or directory Uninstall MacPorts with: sudo port -fp uninstall --follow-dependents installed","title":"Troubleshooting"},{"location":"installation/iOS/","text":"English Installazione Prerequisiti SDK supporta iOS 10+ Autoconf installato Automake installato Libtool installato \u00c8 consigliato l'utilizzo del gestori di pacchetti MacOS Brew per l'installazione di Autoconf , Automake e Libtool . # Install Brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # Install Autoconf, Automake and Libtool brew install autoconf automake libtool Installazione con Cocoapods L'SDK Conio \u00e8 disponibile come Pod ed \u00e8 possibile includerla nei progetti aggiungendo le seguenti righe al Podfile: # The ConioSDK Core pod 'ConioSDK', :git => 'git@bitbucket.org:squadrone/conio-swift-sdk.git', :branch => 'master' # BitcoinKit for encryption purposes pod 'BitcoinKit', :git => 'https://github.com/Conio/BitcoinKit.git', :branch => 'keyconvert' Eseguire il comando pod install nella cartella per ottenere l'SDK. --- Possibili Errori nell'installazione Se si dovesse verificare il seguente messaggio di errore: autoreconf: failed to run aclocal: No such file or directory Eseguire il comando: brew install autoconf && brew install automake . Se si dovesse verificare il seguente messaggio di errore: Can't exec \"/opt/local/bin/aclocal\": No such file or directory Disinstallare dal sistema MacPorts eseguendo: sudo port -fp uninstall --follow-dependents installed","title":"iOS"},{"location":"installation/iOS/#installazione","text":"","title":"Installazione"},{"location":"installation/iOS/#prerequisiti","text":"SDK supporta iOS 10+ Autoconf installato Automake installato Libtool installato \u00c8 consigliato l'utilizzo del gestori di pacchetti MacOS Brew per l'installazione di Autoconf , Automake e Libtool . # Install Brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # Install Autoconf, Automake and Libtool brew install autoconf automake libtool","title":"Prerequisiti"},{"location":"installation/iOS/#installazione-con-cocoapods","text":"L'SDK Conio \u00e8 disponibile come Pod ed \u00e8 possibile includerla nei progetti aggiungendo le seguenti righe al Podfile: # The ConioSDK Core pod 'ConioSDK', :git => 'git@bitbucket.org:squadrone/conio-swift-sdk.git', :branch => 'master' # BitcoinKit for encryption purposes pod 'BitcoinKit', :git => 'https://github.com/Conio/BitcoinKit.git', :branch => 'keyconvert' Eseguire il comando pod install nella cartella per ottenere l'SDK.","title":"Installazione con Cocoapods"},{"location":"installation/iOS/#-","text":"","title":"---"},{"location":"installation/iOS/#possibili-errori-nellinstallazione","text":"Se si dovesse verificare il seguente messaggio di errore: autoreconf: failed to run aclocal: No such file or directory Eseguire il comando: brew install autoconf && brew install automake . Se si dovesse verificare il seguente messaggio di errore: Can't exec \"/opt/local/bin/aclocal\": No such file or directory Disinstallare dal sistema MacPorts eseguendo: sudo port -fp uninstall --follow-dependents installed","title":"Possibili Errori nell'installazione"},{"location":"operation/CryptoRequest/","text":"English: This page isn't translated to English. Crypto Request Alcune funzionalit\u00e0 del SDK Conio sono protette da un meccanismo chiamato Crypto Request , che aggiunge un livello di sicurezza ulteriore all'invio di alcuni parametri, tramite una firma crittografica. Le richieste che sfruttano questo meccanismo sono riconoscibili dalla presenza della propriet\u00e0 cryptoRequest , di tipo [Name]CryptoRequest , presente nella funzione di costruzione (costruttore o metodo factory) del oggetto da passare come parametro all'operazione. In particolare, le funzionalit\u00e0 protette da questo meccanismo sono: userService.signup , registrazione dell'utente ( SignupCryptoRequest ); userService.login , autenticazione dell'utente ( LoginCryptoRequest ); exchangeService.purchase , acquisto di Bitcoin ( BidCryptoRequest ); exchangeService.sell , vendita di Bitcoin ( AskCryptoRequest ). La costruzione di ogni propriet\u00e0 di tipo [Name]CryptoRequest necessita di un parametro cryptoProof , un array di byte , ottenuto tramite firma RSA del hash SHA256 della concatenazione (con separatore \"|\") ordinata delle altre propriet\u00e0 del tipo [Name]CryptoRequest (come descritto per ogni tipo [Name]CryptoRequest nel apposito paragrafo). NFC=<implementazione algoritmo di conversione stringa - array di byte> SHA256=<implementazione algoritmo di hashing SHA256> RSA_SIGN=<implementazione algoritmo di firma RSA> CRYPTO_PROOF = RSA_SIGN(SHA256(NFC(DATA_TO_SIGN))) Creazione SignupCryptoRequest Propriet\u00e0 proofID : di tipo String , identificativo della Crypto Request; userID : di tipo String , identificativo esterno del utente; userLevel : di tipo String , livello del utente che ne stabilisce i limiti di compravendita; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; @Opzionale iban : di tipo String , iban del conto bancario associato all'utente, utilizzato come metodo di pagamento per le operazioni di vendita; email : di tipo String , email dell'utente; firstName : di tipo String , nome dell'utente; lastName : di tipo String , cognome dell'utente; DATA_TO_SIGN DATA_TO_SIGN=\"<proofID>|SIGNUP|<userID>|<userLevel>|<proofExpiration>|<email>|<firstName>|<lastName>\" or DATA_TO_SIGN=\"<proofID>|SIGNUP|<userID>|<userLevel>|<proofExpiration>|<iban>|<email>|<firstName>|<lastName>\" Nota : il campo iban \u00e8 opzionale, pertanto, se non lo si inserisce nella SignupCryptoReqeust , va rimosso anche dalla stringa DATA_TO_SIGN (insieme al separatore \"|\") Creazione LoginCryptoRequest Propriet\u00e0 userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; DATA_TO_SIGN DATA_TO_SIGN=\"<userID>|LOGIN|<proofExpiration>\" Creazione AskCryptoRequest Propriet\u00e0 proofID : di tipo String , identificativo della Crypto Request; askID : di tipo String , identificativo della CreatedAsk che si vuole finalizzare; userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; DATA_TO_SIGN DATA_TO_SIGN=\"<proofID>|PAY_FOR_ASK|<askID>|<userID>|<proofExpiration>\" Creazione BidCryptoRequest Propriet\u00e0 proofID : di tipo String , identificativo della Crypto Request; bidID : di tipo String , identificativo dell CreatedBid che si vuole finalizzare; userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; DATA_TO_SIGN DATA_TO_SIGN=\"<proofID>|PAY_FOR_BID_WT|<bidID>|<userID>|<proofExpiration>\"","title":"Crypto Request"},{"location":"operation/CryptoRequest/#crypto-request","text":"Alcune funzionalit\u00e0 del SDK Conio sono protette da un meccanismo chiamato Crypto Request , che aggiunge un livello di sicurezza ulteriore all'invio di alcuni parametri, tramite una firma crittografica. Le richieste che sfruttano questo meccanismo sono riconoscibili dalla presenza della propriet\u00e0 cryptoRequest , di tipo [Name]CryptoRequest , presente nella funzione di costruzione (costruttore o metodo factory) del oggetto da passare come parametro all'operazione. In particolare, le funzionalit\u00e0 protette da questo meccanismo sono: userService.signup , registrazione dell'utente ( SignupCryptoRequest ); userService.login , autenticazione dell'utente ( LoginCryptoRequest ); exchangeService.purchase , acquisto di Bitcoin ( BidCryptoRequest ); exchangeService.sell , vendita di Bitcoin ( AskCryptoRequest ). La costruzione di ogni propriet\u00e0 di tipo [Name]CryptoRequest necessita di un parametro cryptoProof , un array di byte , ottenuto tramite firma RSA del hash SHA256 della concatenazione (con separatore \"|\") ordinata delle altre propriet\u00e0 del tipo [Name]CryptoRequest (come descritto per ogni tipo [Name]CryptoRequest nel apposito paragrafo). NFC=<implementazione algoritmo di conversione stringa - array di byte> SHA256=<implementazione algoritmo di hashing SHA256> RSA_SIGN=<implementazione algoritmo di firma RSA> CRYPTO_PROOF = RSA_SIGN(SHA256(NFC(DATA_TO_SIGN)))","title":"Crypto Request"},{"location":"operation/CryptoRequest/#creazione-signupcryptorequest","text":"","title":"Creazione SignupCryptoRequest"},{"location":"operation/CryptoRequest/#proprieta","text":"proofID : di tipo String , identificativo della Crypto Request; userID : di tipo String , identificativo esterno del utente; userLevel : di tipo String , livello del utente che ne stabilisce i limiti di compravendita; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida; @Opzionale iban : di tipo String , iban del conto bancario associato all'utente, utilizzato come metodo di pagamento per le operazioni di vendita; email : di tipo String , email dell'utente; firstName : di tipo String , nome dell'utente; lastName : di tipo String , cognome dell'utente;","title":"Propriet\u00e0"},{"location":"operation/CryptoRequest/#data_to_sign","text":"DATA_TO_SIGN=\"<proofID>|SIGNUP|<userID>|<userLevel>|<proofExpiration>|<email>|<firstName>|<lastName>\" or DATA_TO_SIGN=\"<proofID>|SIGNUP|<userID>|<userLevel>|<proofExpiration>|<iban>|<email>|<firstName>|<lastName>\" Nota : il campo iban \u00e8 opzionale, pertanto, se non lo si inserisce nella SignupCryptoReqeust , va rimosso anche dalla stringa DATA_TO_SIGN (insieme al separatore \"|\")","title":"DATA_TO_SIGN"},{"location":"operation/CryptoRequest/#creazione-logincryptorequest","text":"","title":"Creazione LoginCryptoRequest"},{"location":"operation/CryptoRequest/#proprieta_1","text":"userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida;","title":"Propriet\u00e0"},{"location":"operation/CryptoRequest/#data_to_sign_1","text":"DATA_TO_SIGN=\"<userID>|LOGIN|<proofExpiration>\"","title":"DATA_TO_SIGN"},{"location":"operation/CryptoRequest/#creazione-askcryptorequest","text":"","title":"Creazione AskCryptoRequest"},{"location":"operation/CryptoRequest/#proprieta_2","text":"proofID : di tipo String , identificativo della Crypto Request; askID : di tipo String , identificativo della CreatedAsk che si vuole finalizzare; userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida;","title":"Propriet\u00e0"},{"location":"operation/CryptoRequest/#data_to_sign_2","text":"DATA_TO_SIGN=\"<proofID>|PAY_FOR_ASK|<askID>|<userID>|<proofExpiration>\"","title":"DATA_TO_SIGN"},{"location":"operation/CryptoRequest/#creazione-bidcryptorequest","text":"","title":"Creazione BidCryptoRequest"},{"location":"operation/CryptoRequest/#proprieta_3","text":"proofID : di tipo String , identificativo della Crypto Request; bidID : di tipo String , identificativo dell CreatedBid che si vuole finalizzare; userID : di tipo String , identificativo esterno del utente; proofExpiration : di tipo long , istante temporale dopo il quale la Crypto Request non \u00e8 pi\u00f9 considerata valida;","title":"Propriet\u00e0"},{"location":"operation/CryptoRequest/#data_to_sign_3","text":"DATA_TO_SIGN=\"<proofID>|PAY_FOR_BID_WT|<bidID>|<userID>|<proofExpiration>\"","title":"DATA_TO_SIGN"},{"location":"operation/Operation/","text":"English: This page isn't translated to English. Operazioni Introduzione Una volta inizializzato l'oggetto Conio , i servizi offerti dal SDK sono raggruppati in 3 categorie: Servizi dell'utente ( conio.userService.* ); Servizi del wallet ( conio.walletService.* ); Servizi di mercato ( conio.exchangeService.* ). Ogni servizio \u00e8 un metodo il cui valore di ritorno \u00e8 un implementazione dell'interfaccia ServiceConsumer<O> . ServiceConsumer L'interfaccia ServiceConsumer<O> (generica in O , il tipo che rappresenta il risultato del servizio stesso) dichiara le modalit\u00e0 con cui i risultati dei servizi possono essere fruiti, infatti espone i metodi: asCallbeck , che richiede come parametro una callback che verr\u00e0 invocata con il risultato del servizio; (Android) asFlow , che restituisce un oggetto di tipo Flow , pi\u00f9 adatto al paradigma di programmazione reattiva; (iOS) asPublisher , TODO. Code Android (Java) conio.walletService.currentBitcoinAddress().asCallback(result -> result.analysis( address -> { /* ... */ }, error -> { /* ... */ } )); Android (Kotlin) runBlocking { conio.walletService.currentBitcoinAddress().asFlow().first().analysis( { address -> /* ... */ }, { error -> /* ... */ } ) } Eccezioni possibili ConioError Questo errore raggruppa tutte le possibili risposte di errore direttamente legate alle operazioni. iOS // General operation error with name and/or description case onOperation(String) // Decoding data error case unableToDecodeData // Cryptographic operation error case onCryptography // Secure storage operation error case onStorage // OAuth flow error: unable to retrieve and/or refresh access token case unauthorized // TBD case appImprovementAcceptanceNotAccepted // TBD case clientSupportAcceptanceNotAccepted // Ask operation already paid case askAlreadyPaid // Bid operation already paid case bidAlreadyPaid // Bid operation is expired case bidExpired // TBD case bidIsInError // Bid operation is not yet paid case bidNotYetPaid case bithustlerServiceCouldNotCreateSeller // TBD case cardsLimitsExceeded case cardsServiceCouldNotCreatePayer case duplicateEmailAddress case dustAsk case dustTransaction // Fiat amount is under the minumum level limit case fiatAmountTooLow case inconsistentState case inconsistentTransaction case invalidIban case invalidMessageSignature // Used payment method is not valid case invalidPaymentMethod case invalidToken case invalidTokenPayload // Crypto proof used for operation is invalid case invalidCryptoProof case multipleSellMethods case noSuch3DSecure case noSuchSellMethod // TBD case noSuchSeller // TBD case noSuchWallet case noSuchWithdrawalFeesInfo case notEnoughBtcAmount case tradeExpired // Bid operation exceeded user purchase max limits case tradingLimitsExceeded case unavailableBtcSubsystem // Ask operation is in an error status case unrecoverableAsk // Bid operation is in an error status case unrecoverableBid // Payment method used in not supported case unsupportedPaymentMethod case walletAlreadyCreatedWithDifferentKeys case walletAlreadyOwnedByAnotherUser // Unknown error with description case unknown(String) // Conio SDK version is outdated case outdatedSdk // Server is under maintenance case underMaintenance Android TBD Ad esempio, prendiamo l'operazione conio.walletService.withdrawalFees : se un utente ha 1 bitcoin nel portafoglio e richiede le mining fees per un invio da 50 bitcoin, ricever\u00e0 un NO_SUCH_WITHDRAWAL_FEES_INFO . Code Android WithdrawalFeesParams params = new WithdrawalFeesParams( \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 100000000, TransactionSpeedType.SPEED_FIVE ); conio.walletService.withdrawalFees(params).asCallback(result -> result.analysis( fees -> { /* ... */ }, error -> { ConioException conioException = (ConioException) error; if (conioException.getConioError() == ConioError.NO_SUCH_WITHDRAWAL_FEES_INFO) { /* Handle NO_SUCH_WITHDRAWAL_FEES_INFO error */ } } )); Non autorizzato Questo errore viene generato quando non si \u00e8 autorizzati a utilizzare un metodo per uno dei seguenti motivi: utilizzo di un metodo che richiede autenticazione senza una sessione valida; si sta provando ad effettura una login con credenziali errate. Assicurarsi di avere una sessione valida, autenticandosi nuovamente tramite una login o una sign-up . Codice Android UserLogin user = new UserLogin(\"username\", \"wrong_password\"); conio.userService.login(user).asCallback(result -> result.analysis( success -> { /* ... */ }, error -> { if (error instanceof UnauthorizedException) { /* Handle the error */ } // Or ServiceException serviceException = (ServiceException) error; if (serviceException.getServiceError() == ServiceError.UNAUTHORIZED) { /* Handle the error */ } } )); SDK obsoleto Questo errore viene generato quando l'utente tenta di utilizzare una versione obsoleta dell'SDK. Consigliamo di gestire questo errore per notificare all'utente di aggiornare l'applicazione. Code Android LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params).asCallback(result -> result.analysis( acceptances -> { /* ... */ }, error -> { if (error instanceof OutdatedSDKException) { /* Handle the error */ } // Or ServiceException serviceException = (ServiceException) error; if (serviceException.getServiceError() == ServiceError.OUTDATED_SDK) { /* Handle the error */ } } )); iOS let params = LegalAcceptancesParams(language: .italian) conio.userService.getLegalAcceptances(params: params).asCallback { result in switch result { case .success: // success case .failure(let error): if case .outdatedSDK = error { print(\"Please update the SDK\") } } }","title":"Generale"},{"location":"operation/Operation/#operazioni","text":"","title":"Operazioni"},{"location":"operation/Operation/#introduzione","text":"Una volta inizializzato l'oggetto Conio , i servizi offerti dal SDK sono raggruppati in 3 categorie: Servizi dell'utente ( conio.userService.* ); Servizi del wallet ( conio.walletService.* ); Servizi di mercato ( conio.exchangeService.* ). Ogni servizio \u00e8 un metodo il cui valore di ritorno \u00e8 un implementazione dell'interfaccia ServiceConsumer<O> .","title":"Introduzione"},{"location":"operation/Operation/#serviceconsumer","text":"L'interfaccia ServiceConsumer<O> (generica in O , il tipo che rappresenta il risultato del servizio stesso) dichiara le modalit\u00e0 con cui i risultati dei servizi possono essere fruiti, infatti espone i metodi: asCallbeck , che richiede come parametro una callback che verr\u00e0 invocata con il risultato del servizio; (Android) asFlow , che restituisce un oggetto di tipo Flow , pi\u00f9 adatto al paradigma di programmazione reattiva; (iOS) asPublisher , TODO.","title":"ServiceConsumer"},{"location":"operation/Operation/#code","text":"","title":"Code"},{"location":"operation/Operation/#android-java","text":"conio.walletService.currentBitcoinAddress().asCallback(result -> result.analysis( address -> { /* ... */ }, error -> { /* ... */ } ));","title":"Android (Java)"},{"location":"operation/Operation/#android-kotlin","text":"runBlocking { conio.walletService.currentBitcoinAddress().asFlow().first().analysis( { address -> /* ... */ }, { error -> /* ... */ } ) }","title":"Android (Kotlin)"},{"location":"operation/Operation/#eccezioni-possibili","text":"","title":"Eccezioni possibili"},{"location":"operation/Operation/#conioerror","text":"Questo errore raggruppa tutte le possibili risposte di errore direttamente legate alle operazioni.","title":"ConioError"},{"location":"operation/Operation/#ios","text":"// General operation error with name and/or description case onOperation(String) // Decoding data error case unableToDecodeData // Cryptographic operation error case onCryptography // Secure storage operation error case onStorage // OAuth flow error: unable to retrieve and/or refresh access token case unauthorized // TBD case appImprovementAcceptanceNotAccepted // TBD case clientSupportAcceptanceNotAccepted // Ask operation already paid case askAlreadyPaid // Bid operation already paid case bidAlreadyPaid // Bid operation is expired case bidExpired // TBD case bidIsInError // Bid operation is not yet paid case bidNotYetPaid case bithustlerServiceCouldNotCreateSeller // TBD case cardsLimitsExceeded case cardsServiceCouldNotCreatePayer case duplicateEmailAddress case dustAsk case dustTransaction // Fiat amount is under the minumum level limit case fiatAmountTooLow case inconsistentState case inconsistentTransaction case invalidIban case invalidMessageSignature // Used payment method is not valid case invalidPaymentMethod case invalidToken case invalidTokenPayload // Crypto proof used for operation is invalid case invalidCryptoProof case multipleSellMethods case noSuch3DSecure case noSuchSellMethod // TBD case noSuchSeller // TBD case noSuchWallet case noSuchWithdrawalFeesInfo case notEnoughBtcAmount case tradeExpired // Bid operation exceeded user purchase max limits case tradingLimitsExceeded case unavailableBtcSubsystem // Ask operation is in an error status case unrecoverableAsk // Bid operation is in an error status case unrecoverableBid // Payment method used in not supported case unsupportedPaymentMethod case walletAlreadyCreatedWithDifferentKeys case walletAlreadyOwnedByAnotherUser // Unknown error with description case unknown(String) // Conio SDK version is outdated case outdatedSdk // Server is under maintenance case underMaintenance","title":"iOS"},{"location":"operation/Operation/#android","text":"TBD Ad esempio, prendiamo l'operazione conio.walletService.withdrawalFees : se un utente ha 1 bitcoin nel portafoglio e richiede le mining fees per un invio da 50 bitcoin, ricever\u00e0 un NO_SUCH_WITHDRAWAL_FEES_INFO .","title":"Android"},{"location":"operation/Operation/#code_1","text":"","title":"Code"},{"location":"operation/Operation/#android_1","text":"WithdrawalFeesParams params = new WithdrawalFeesParams( \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 100000000, TransactionSpeedType.SPEED_FIVE ); conio.walletService.withdrawalFees(params).asCallback(result -> result.analysis( fees -> { /* ... */ }, error -> { ConioException conioException = (ConioException) error; if (conioException.getConioError() == ConioError.NO_SUCH_WITHDRAWAL_FEES_INFO) { /* Handle NO_SUCH_WITHDRAWAL_FEES_INFO error */ } } ));","title":"Android"},{"location":"operation/Operation/#non-autorizzato","text":"Questo errore viene generato quando non si \u00e8 autorizzati a utilizzare un metodo per uno dei seguenti motivi: utilizzo di un metodo che richiede autenticazione senza una sessione valida; si sta provando ad effettura una login con credenziali errate. Assicurarsi di avere una sessione valida, autenticandosi nuovamente tramite una login o una sign-up .","title":"Non autorizzato"},{"location":"operation/Operation/#codice","text":"","title":"Codice"},{"location":"operation/Operation/#android_2","text":"UserLogin user = new UserLogin(\"username\", \"wrong_password\"); conio.userService.login(user).asCallback(result -> result.analysis( success -> { /* ... */ }, error -> { if (error instanceof UnauthorizedException) { /* Handle the error */ } // Or ServiceException serviceException = (ServiceException) error; if (serviceException.getServiceError() == ServiceError.UNAUTHORIZED) { /* Handle the error */ } } ));","title":"Android"},{"location":"operation/Operation/#sdk-obsoleto","text":"Questo errore viene generato quando l'utente tenta di utilizzare una versione obsoleta dell'SDK. Consigliamo di gestire questo errore per notificare all'utente di aggiornare l'applicazione.","title":"SDK obsoleto"},{"location":"operation/Operation/#code_2","text":"","title":"Code"},{"location":"operation/Operation/#android_3","text":"LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params).asCallback(result -> result.analysis( acceptances -> { /* ... */ }, error -> { if (error instanceof OutdatedSDKException) { /* Handle the error */ } // Or ServiceException serviceException = (ServiceException) error; if (serviceException.getServiceError() == ServiceError.OUTDATED_SDK) { /* Handle the error */ } } ));","title":"Android"},{"location":"operation/Operation/#ios_1","text":"let params = LegalAcceptancesParams(language: .italian) conio.userService.getLegalAcceptances(params: params).asCallback { result in switch result { case .success: // success case .failure(let error): if case .outdatedSDK = error { print(\"Please update the SDK\") } } }","title":"iOS"},{"location":"user/User.en/","text":"Italiano User operations Terms and conditions Using this operation you can retrieve the Acceptances (terms and conditions), T&C URL and Privacy Policy URL that the user has to accept during the signup. Parameters An object LegalAcceptancesParams with the language you want. Returns A LegalAcceptances object containing Acceptances , the URL Termini di Servizio and the URL Privacy Policies . Acceptances localization An Acceptance has 2 localization keys: one for the title and one for the content. Code Android LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params, result -> { result.analysis(acceptances -> { // LegalAcceptances }, error -> { // Exception }); }); iOS let params = LegalAcceptancesParams(language: .italian) conio.userService.getLegalAcceptances(params: params) { result in result.analysis(ifSuccess: { legalAcceptances in // LegalAcceptances }, ifFailure: { error in // ServiceError }) } Signup To use the wallet the user has to be authenticated. If it's the first time you can authenticate using the signup method, otherwise you have to use the login method. Parameters An Account struct containing: login : Login on iOS or UserLogin on Android: username and password of the user. acceptances : Acceptances containing booleans about the user consent to T&C cryptoRequest : create a CryptoRequest : Crypto Request Creation Crypto Request Creation To generate a Crypto Request , you have to sign the string: dataString (create one by following the example below), using the function sha256 and the private key. The following lines of code are just an example. The actual implementation of the signing algorithm to include in the CryptoRequest is up to the client. Java Example String proofId = UUID.randomUUID().toString(); long proofExpiration = new Date() .tenMinutesFromNow() .millis(); String userLevel = \"A smart level\"; // Es. \"Advanced\" to get adavanced limits String userId = login.username; String iban = \"IBAN\"; // It should be a real iban String email = \"user@email.com\"; String firstName = \"Mario\"; String lastName = \"Rossi\"; String[] data = { proofId, \"SIGNUP\", userId, userLevel, String.valueOf(proofExpiration), iban, email, firstName, lastName }; String dataString = join(\"|\", data); PrivateKey privateKey = new PrivateKey(\"key.pem\"); RsaSigner rsa = new RsaSigner(privateKey); String signature = rsa .sign(\"sha256\", dataString) .toLowercase(); byte[] cryptoProof = fromHexToBytes(signature); Swift Example let proofID = UUID().uuidString let proofExpiration: UInt64 = UInt64(Date()) let userLevel = \"A smart level\" // Es. \"Advanced\" to get adavanced limits let userID = login.username let iban = \"IBAN\" // It should be a real iban let email = \"user@email.com\" let firstName = \"Mario\" let lastName = \"Rossi\" let data = [ proofID, \"SIGNUP\", userID, userLevel, String(proofExpiration), iban, firstName, lastName ] let dataString = data.joined(separator: \"|\") let cryptoProof = Crypto.sign( privateKey: privateKey, digestType: .sha256 ) let cryptoRequest = CryptoRequest( proofID: proofID, cryptoProof: cryptoProof.data, proofExpiration: proofExpiration, userID: userID, userLevel: userLevel, iban: iban, email: email, firstName: firstName, lastName: lastName ) Returns An object Acceptances confirming which T&C the user approved during the signup. Errori INVALID_IBAN CRYPTO_PROOF_EXPIRED INVALID_CRYPTO_PROOF Crypto proof was signed incorrectly CARDS_SERVICE_COULD_NOT_CREATE_PAYER Internal error of the payment system DUPLICATE_EMAIL_ADDRESS WALLET_ALREADY_OWNED_BY_ANOTHER_USER CLIENT_SUPPORT_ACCEPTANCE_NOT_ACCEPTED Required acceptance APP_IMPROVEMENT_ACCEPTANCE_NOT_ACCEPTED Required acceptance Code Android UserLogin login = new UserLogin(\"lemonade\", \"secretword\"); // Build the acceptances list with the user choices result Acceptance appImprovement = new Acceptance(AcceptanceType.APP_IMPROVEMENT, true); Acceptance clientSupport = new Acceptance(AcceptanceType.CLIENT_SUPPORT, true); ArrayList<Acceptance> acceptanceList = new ArrayList<>(); acceptanceList.add(appImprovement); acceptanceList.add(clientSupport); Acceptances acceptances = new Acceptances(acceptanceList); // Your crypto request implementation CryptoRequest cryptoRequest = buildCryptoRequest(); Account account = new Account(login, acceptances, cryptoRequest); conio.userService.signup(account, result -> { result.analysis(acceptances -> { // Acceptances }, error -> { // Exception }); }); iOS let login = Login(username: \"lemonade\", password: \"secretword\") // Your crypto request implementation let cryptoRequest = buildCryptoRequest() // Build the acceptances list with the user choices result let appImprovement = Acceptance(type: .appImprovement, isAccepted: true) let clientSupport = Acceptance(type: .clientSupport, isAccepted: true) let acceptancesList = [appImprovement, clientSupport] let acceptances = Acceptances(acceptances: acceptancesList) let account = Account( login: login, acceptances: acceptances, cryptoRequest: cryptoRequest ) conio.userService.signup(with: account) { result in result.analysis(ifSuccess: { acceptances in // Acceptances }, ifFailure: { error in // ServiceError }) } Login Using the login operation you can authenticate to Conio. It is recommended to perform this operation every time the app is started. Parameters An object, called Login on iOS or UserLogin on Android, containing: username password Returns An Acceptances object with the T&C that the user accepted on signup. Code Android UserLogin login = new UserLogin(\"lemonade\", \"secretword\"); conio.userService.login(login, result -> { result.analysis(acceptances -> { // Acceptances }, error -> { // Exception }); }); iOS let login = Login(username: \"lemonade\",password: \"secretword\") conio.userService.login(with: login) { result in result.analysis(ifSuccess: { acceptances in // Acceptances }, ifFailure: { error in // ServiceError }) } Logout Disconnect from Conio. Returns A boolean with the result of the operation. Codice Android conio.userService.logout(result -> { result.analysis(success -> { // Boolean }, error -> { // Exception }); }); iOS conio.userService.logout { result in result.analysis(ifSuccess: { success in // Boolean }, ifFailure: { error in // ServiceError }) }","title":"user"},{"location":"user/User.en/#user-operations","text":"","title":"User operations"},{"location":"user/User.en/#terms-and-conditions","text":"Using this operation you can retrieve the Acceptances (terms and conditions), T&C URL and Privacy Policy URL that the user has to accept during the signup.","title":"Terms and conditions"},{"location":"user/User.en/#parameters","text":"An object LegalAcceptancesParams with the language you want.","title":"Parameters"},{"location":"user/User.en/#returns","text":"A LegalAcceptances object containing Acceptances , the URL Termini di Servizio and the URL Privacy Policies .","title":"Returns"},{"location":"user/User.en/#acceptances-localization","text":"An Acceptance has 2 localization keys: one for the title and one for the content.","title":"Acceptances localization"},{"location":"user/User.en/#code","text":"","title":"Code"},{"location":"user/User.en/#android","text":"LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params, result -> { result.analysis(acceptances -> { // LegalAcceptances }, error -> { // Exception }); });","title":"Android"},{"location":"user/User.en/#ios","text":"let params = LegalAcceptancesParams(language: .italian) conio.userService.getLegalAcceptances(params: params) { result in result.analysis(ifSuccess: { legalAcceptances in // LegalAcceptances }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"user/User.en/#signup","text":"To use the wallet the user has to be authenticated. If it's the first time you can authenticate using the signup method, otherwise you have to use the login method.","title":"Signup"},{"location":"user/User.en/#parameters_1","text":"An Account struct containing: login : Login on iOS or UserLogin on Android: username and password of the user. acceptances : Acceptances containing booleans about the user consent to T&C cryptoRequest : create a CryptoRequest : Crypto Request Creation","title":"Parameters"},{"location":"user/User.en/#crypto-request-creation","text":"To generate a Crypto Request , you have to sign the string: dataString (create one by following the example below), using the function sha256 and the private key. The following lines of code are just an example. The actual implementation of the signing algorithm to include in the CryptoRequest is up to the client.","title":"Crypto Request Creation"},{"location":"user/User.en/#java-example","text":"String proofId = UUID.randomUUID().toString(); long proofExpiration = new Date() .tenMinutesFromNow() .millis(); String userLevel = \"A smart level\"; // Es. \"Advanced\" to get adavanced limits String userId = login.username; String iban = \"IBAN\"; // It should be a real iban String email = \"user@email.com\"; String firstName = \"Mario\"; String lastName = \"Rossi\"; String[] data = { proofId, \"SIGNUP\", userId, userLevel, String.valueOf(proofExpiration), iban, email, firstName, lastName }; String dataString = join(\"|\", data); PrivateKey privateKey = new PrivateKey(\"key.pem\"); RsaSigner rsa = new RsaSigner(privateKey); String signature = rsa .sign(\"sha256\", dataString) .toLowercase(); byte[] cryptoProof = fromHexToBytes(signature);","title":"Java Example"},{"location":"user/User.en/#swift-example","text":"let proofID = UUID().uuidString let proofExpiration: UInt64 = UInt64(Date()) let userLevel = \"A smart level\" // Es. \"Advanced\" to get adavanced limits let userID = login.username let iban = \"IBAN\" // It should be a real iban let email = \"user@email.com\" let firstName = \"Mario\" let lastName = \"Rossi\" let data = [ proofID, \"SIGNUP\", userID, userLevel, String(proofExpiration), iban, firstName, lastName ] let dataString = data.joined(separator: \"|\") let cryptoProof = Crypto.sign( privateKey: privateKey, digestType: .sha256 ) let cryptoRequest = CryptoRequest( proofID: proofID, cryptoProof: cryptoProof.data, proofExpiration: proofExpiration, userID: userID, userLevel: userLevel, iban: iban, email: email, firstName: firstName, lastName: lastName )","title":"Swift Example"},{"location":"user/User.en/#returns_1","text":"An object Acceptances confirming which T&C the user approved during the signup.","title":"Returns"},{"location":"user/User.en/#errori","text":"INVALID_IBAN CRYPTO_PROOF_EXPIRED INVALID_CRYPTO_PROOF Crypto proof was signed incorrectly CARDS_SERVICE_COULD_NOT_CREATE_PAYER Internal error of the payment system DUPLICATE_EMAIL_ADDRESS WALLET_ALREADY_OWNED_BY_ANOTHER_USER CLIENT_SUPPORT_ACCEPTANCE_NOT_ACCEPTED Required acceptance APP_IMPROVEMENT_ACCEPTANCE_NOT_ACCEPTED Required acceptance","title":"Errori"},{"location":"user/User.en/#code_1","text":"","title":"Code"},{"location":"user/User.en/#android_1","text":"UserLogin login = new UserLogin(\"lemonade\", \"secretword\"); // Build the acceptances list with the user choices result Acceptance appImprovement = new Acceptance(AcceptanceType.APP_IMPROVEMENT, true); Acceptance clientSupport = new Acceptance(AcceptanceType.CLIENT_SUPPORT, true); ArrayList<Acceptance> acceptanceList = new ArrayList<>(); acceptanceList.add(appImprovement); acceptanceList.add(clientSupport); Acceptances acceptances = new Acceptances(acceptanceList); // Your crypto request implementation CryptoRequest cryptoRequest = buildCryptoRequest(); Account account = new Account(login, acceptances, cryptoRequest); conio.userService.signup(account, result -> { result.analysis(acceptances -> { // Acceptances }, error -> { // Exception }); });","title":"Android"},{"location":"user/User.en/#ios_1","text":"let login = Login(username: \"lemonade\", password: \"secretword\") // Your crypto request implementation let cryptoRequest = buildCryptoRequest() // Build the acceptances list with the user choices result let appImprovement = Acceptance(type: .appImprovement, isAccepted: true) let clientSupport = Acceptance(type: .clientSupport, isAccepted: true) let acceptancesList = [appImprovement, clientSupport] let acceptances = Acceptances(acceptances: acceptancesList) let account = Account( login: login, acceptances: acceptances, cryptoRequest: cryptoRequest ) conio.userService.signup(with: account) { result in result.analysis(ifSuccess: { acceptances in // Acceptances }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"user/User.en/#login","text":"Using the login operation you can authenticate to Conio. It is recommended to perform this operation every time the app is started.","title":"Login"},{"location":"user/User.en/#parameters_2","text":"An object, called Login on iOS or UserLogin on Android, containing: username password","title":"Parameters"},{"location":"user/User.en/#returns_2","text":"An Acceptances object with the T&C that the user accepted on signup.","title":"Returns"},{"location":"user/User.en/#code_2","text":"","title":"Code"},{"location":"user/User.en/#android_2","text":"UserLogin login = new UserLogin(\"lemonade\", \"secretword\"); conio.userService.login(login, result -> { result.analysis(acceptances -> { // Acceptances }, error -> { // Exception }); });","title":"Android"},{"location":"user/User.en/#ios_2","text":"let login = Login(username: \"lemonade\",password: \"secretword\") conio.userService.login(with: login) { result in result.analysis(ifSuccess: { acceptances in // Acceptances }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"user/User.en/#logout","text":"Disconnect from Conio.","title":"Logout"},{"location":"user/User.en/#returns_3","text":"A boolean with the result of the operation.","title":"Returns"},{"location":"user/User.en/#codice","text":"","title":"Codice"},{"location":"user/User.en/#android_3","text":"conio.userService.logout(result -> { result.analysis(success -> { // Boolean }, error -> { // Exception }); });","title":"Android"},{"location":"user/User.en/#ios_3","text":"conio.userService.logout { result in result.analysis(ifSuccess: { success in // Boolean }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"user/User/","text":"English Operazioni sull'utente Recupero dei termini di servizio Questa operazione consente di recuperare le LegalAcceptances , ovvero le condizioni che l'utente potr\u00e0/dovr\u00e0 accettare in fase di signup (scelte che, durante l' operazione signup , dovranno essere descritte tramite la classe Acceptances ). L'oggetto LegalAcceptances recuperato conterr\u00e0 gli url per mostrare le pagine dei Termini di Servizio e Privacy Policies di Conio e il dettaglio delle acceptances ( AcceptanceDetail ) che l'utente dovr\u00e0 o meno accettare. Metodo userService.getLegalAcceptances Parametri Un oggetto di tipo LegalAcceptancesParams contenente la lingua di riferimento per ottenere le acceptances e gli url delle pagine web da mostrare all'utente. Risposta Un oggetto di tipo LegalAcceptances contenente la lista degli AcceptanceDetail , lo url dei Termini di Servizio e quello delle Privacy Policies . Codice Android LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params) .asCallback(result -> result.analysis( acceptances -> { /* Handle LegalAcceptances */ }, error -> { /* Handle error */ } )); iOS let params = LegalAcceptancesParams(language: .italian) conio.userService.signup(params: params).asCallback { result in switch result { case .success(let acceptances): // LegalAcceptances case .failure(let error): // Operation Error } } Autenticazione Per poter operare con il portafoglio Conio occorre essere autenticati. Se \u00e8 la prima volta che l'utente usa il servizio ci si pu\u00f2 autenticare con il metodo userService.signup , altrimenti con il metodo userService.login . Signup L'operazione di signup permette di creare un nuovo utente Conio. Metodo userService.signup Parametri Un oggetto di tipo SignupParams , costruito tramite il metodo SignupParams.createCryptoSignup con: acceptances : di tipo Acceptances con l'esito della conferma ai termini di servizio da parte dell'utente, recuperati tramite le LegalAcceptances ; credentials : di tipo ConioCredentials con username e password dell'utente; cryptoRequest : di tipo SignupCryptoRequest , che specifica ulteriori parametri comprovati da una firma, come descritto in creazione della SignupCryptoRequest . Risposta Un oggetto di tipo Success che indica che l'utente \u00e8 stato autenticato. Errori ConioError : APP_IMPROVEMENT_ACCEPTANCE_NOT_ACCEPTED Acceptance obbligatoria; CLIENT_SUPPORT_ACCEPTANCE_NOT_ACCEPTED Acceptance obbligatoria; CRYPTO_PROOF_EXPIRED La crypto proof \u00e8 scaduta; INVALID_CRYPTO_PROOF La crypto proof non \u00e8 correttamente firmata; DUPLICATE_EMAIL_ADDRESS Indirizzo email duplicato; INVALID_IBAN IBAN non valido; WALLET_ALREADY_OWNED_BY_ANOTHER_USER Il wallet \u00e8 gi\u00e0 utilizzato da un altro utente; CARDS_SERVICE_COULD_NOT_CREATE_PAYER Errore interno del sottosistema di pagamento. Codice Android // vedi \"Creazione SignupCryptoRequest\" SignupCryptoRequest cryptoRequest = new SignupCryptoRequest(...); ConioCredentials credentials = new ConioCredentials(\"username\", \"password\"); Acceptances acceptances = new Acceptances(Arrays.asList( new Acceptance(AcceptanceType.CLIENT_SUPPORT, true), new Acceptance(AcceptanceType.APP_IMPROVEMENT, true) )); SignupParams params = SignupParams.createCryptoSignup(acceptances, credentials, cryptoRequest); conio.userService.signup(params) .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } )); iOS // vedi \"Creazione SignupCryptoRequest\" let credentials = ConioCredentials(username: \"username\", password: \"password\") var acceptancesList = [Acceptance]() acceptancesList.append(.init(type: .appImprovement, isAccepted: true)) acceptancesList.append(.init(type: .clientSupport, isAccepted: true)) let acceptances = Acceptances(acceptances: acceptancesList) let cryptoRequest = SignupCryptoRequest.init(proofID: \"\", cryptoProof: Data(), proofExpiration: 0, externalUserID: \"\", userLevel: \"\", iban: \"\", email: \"\", firstName: \"\", lastName: \"\") let signupParams = SignupParams.createCryptoSignup(credentials: credentials, acceptances: acceptances, cryptoRequest: cryptoRequest) conio.userService.signup(params: params).asCallback { result in switch result { case .success: // Handle Succes case .failure(let error): // Operation Error } } Login L'operazione di login permette di autenticarsi a Conio. \u00c8 raccomandabile eseguire questa operazione ad ogni avvio dell'applicazione, similmente a come avviene per altri servizi terzi. Metodo userService.login Parametri Un oggetto di tipo LoginParams , costruito tramite il metodo LoginParams.createCryptoLogin con: credentials : di tipo ConioCredentials con username e password dell'utente cryptoRequest : di tipo LoginCryptoRequest , che specifica ulteriori parametri comprovati da una firma, come descritto in creazione della LoginCryptoRequest . Risposta Un oggetto di tipo Success che indica che l'utente \u00e8 stato autenticato. Errori Non autorizzato Codice Android LoginCryptoRequest cryptoRequest = new LoginCryptoRequest(...); ConioCredentials credentials = new ConioCredentials(\"username\", \"password\"); LoginParams params = LoginParams.createCryptoLogin(credentials, cryptoRequest); conio.userService.login(params) .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } )); iOS let params = LoginParams(username: \"lemonade\", password: \"secretword\", loginCryptoRequest: <LoginCryptoRequest>) conio.userService.login(params: params).asCallback { result in switch result { case .success: // success case .failure(let error): // Operation Error } } Logout Consente di disconnettere l'utenza Conio. Metodo userService.logout Risposta Un oggetto di tipo Success che indica che l'utente \u00e8 stato disconnesso. Codice Android conio.userService.logout() .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } )); iOS conio.userService.logout().asCallback { result in switch result { case .success: // success case .failure(let error): // Operation Error } }","title":"user"},{"location":"user/User/#operazioni-sullutente","text":"","title":"Operazioni sull'utente"},{"location":"user/User/#recupero-dei-termini-di-servizio","text":"Questa operazione consente di recuperare le LegalAcceptances , ovvero le condizioni che l'utente potr\u00e0/dovr\u00e0 accettare in fase di signup (scelte che, durante l' operazione signup , dovranno essere descritte tramite la classe Acceptances ). L'oggetto LegalAcceptances recuperato conterr\u00e0 gli url per mostrare le pagine dei Termini di Servizio e Privacy Policies di Conio e il dettaglio delle acceptances ( AcceptanceDetail ) che l'utente dovr\u00e0 o meno accettare.","title":"Recupero dei termini di servizio"},{"location":"user/User/#metodo","text":"userService.getLegalAcceptances","title":"Metodo"},{"location":"user/User/#parametri","text":"Un oggetto di tipo LegalAcceptancesParams contenente la lingua di riferimento per ottenere le acceptances e gli url delle pagine web da mostrare all'utente.","title":"Parametri"},{"location":"user/User/#risposta","text":"Un oggetto di tipo LegalAcceptances contenente la lista degli AcceptanceDetail , lo url dei Termini di Servizio e quello delle Privacy Policies .","title":"Risposta"},{"location":"user/User/#codice","text":"","title":"Codice"},{"location":"user/User/#android","text":"LegalAcceptancesParams params = new LegalAcceptancesParams(Language.ITALIAN); conio.userService.getLegalAcceptances(params) .asCallback(result -> result.analysis( acceptances -> { /* Handle LegalAcceptances */ }, error -> { /* Handle error */ } ));","title":"Android"},{"location":"user/User/#ios","text":"let params = LegalAcceptancesParams(language: .italian) conio.userService.signup(params: params).asCallback { result in switch result { case .success(let acceptances): // LegalAcceptances case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"user/User/#autenticazione","text":"Per poter operare con il portafoglio Conio occorre essere autenticati. Se \u00e8 la prima volta che l'utente usa il servizio ci si pu\u00f2 autenticare con il metodo userService.signup , altrimenti con il metodo userService.login .","title":"Autenticazione"},{"location":"user/User/#signup","text":"L'operazione di signup permette di creare un nuovo utente Conio.","title":"Signup"},{"location":"user/User/#metodo_1","text":"userService.signup","title":"Metodo"},{"location":"user/User/#parametri_1","text":"Un oggetto di tipo SignupParams , costruito tramite il metodo SignupParams.createCryptoSignup con: acceptances : di tipo Acceptances con l'esito della conferma ai termini di servizio da parte dell'utente, recuperati tramite le LegalAcceptances ; credentials : di tipo ConioCredentials con username e password dell'utente; cryptoRequest : di tipo SignupCryptoRequest , che specifica ulteriori parametri comprovati da una firma, come descritto in creazione della SignupCryptoRequest .","title":"Parametri"},{"location":"user/User/#risposta_1","text":"Un oggetto di tipo Success che indica che l'utente \u00e8 stato autenticato.","title":"Risposta"},{"location":"user/User/#errori","text":"ConioError : APP_IMPROVEMENT_ACCEPTANCE_NOT_ACCEPTED Acceptance obbligatoria; CLIENT_SUPPORT_ACCEPTANCE_NOT_ACCEPTED Acceptance obbligatoria; CRYPTO_PROOF_EXPIRED La crypto proof \u00e8 scaduta; INVALID_CRYPTO_PROOF La crypto proof non \u00e8 correttamente firmata; DUPLICATE_EMAIL_ADDRESS Indirizzo email duplicato; INVALID_IBAN IBAN non valido; WALLET_ALREADY_OWNED_BY_ANOTHER_USER Il wallet \u00e8 gi\u00e0 utilizzato da un altro utente; CARDS_SERVICE_COULD_NOT_CREATE_PAYER Errore interno del sottosistema di pagamento.","title":"Errori"},{"location":"user/User/#codice_1","text":"","title":"Codice"},{"location":"user/User/#android_1","text":"// vedi \"Creazione SignupCryptoRequest\" SignupCryptoRequest cryptoRequest = new SignupCryptoRequest(...); ConioCredentials credentials = new ConioCredentials(\"username\", \"password\"); Acceptances acceptances = new Acceptances(Arrays.asList( new Acceptance(AcceptanceType.CLIENT_SUPPORT, true), new Acceptance(AcceptanceType.APP_IMPROVEMENT, true) )); SignupParams params = SignupParams.createCryptoSignup(acceptances, credentials, cryptoRequest); conio.userService.signup(params) .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } ));","title":"Android"},{"location":"user/User/#ios_1","text":"// vedi \"Creazione SignupCryptoRequest\" let credentials = ConioCredentials(username: \"username\", password: \"password\") var acceptancesList = [Acceptance]() acceptancesList.append(.init(type: .appImprovement, isAccepted: true)) acceptancesList.append(.init(type: .clientSupport, isAccepted: true)) let acceptances = Acceptances(acceptances: acceptancesList) let cryptoRequest = SignupCryptoRequest.init(proofID: \"\", cryptoProof: Data(), proofExpiration: 0, externalUserID: \"\", userLevel: \"\", iban: \"\", email: \"\", firstName: \"\", lastName: \"\") let signupParams = SignupParams.createCryptoSignup(credentials: credentials, acceptances: acceptances, cryptoRequest: cryptoRequest) conio.userService.signup(params: params).asCallback { result in switch result { case .success: // Handle Succes case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"user/User/#login","text":"L'operazione di login permette di autenticarsi a Conio. \u00c8 raccomandabile eseguire questa operazione ad ogni avvio dell'applicazione, similmente a come avviene per altri servizi terzi.","title":"Login"},{"location":"user/User/#metodo_2","text":"userService.login","title":"Metodo"},{"location":"user/User/#parametri_2","text":"Un oggetto di tipo LoginParams , costruito tramite il metodo LoginParams.createCryptoLogin con: credentials : di tipo ConioCredentials con username e password dell'utente cryptoRequest : di tipo LoginCryptoRequest , che specifica ulteriori parametri comprovati da una firma, come descritto in creazione della LoginCryptoRequest .","title":"Parametri"},{"location":"user/User/#risposta_2","text":"Un oggetto di tipo Success che indica che l'utente \u00e8 stato autenticato.","title":"Risposta"},{"location":"user/User/#errori_1","text":"Non autorizzato","title":"Errori"},{"location":"user/User/#codice_2","text":"","title":"Codice"},{"location":"user/User/#android_2","text":"LoginCryptoRequest cryptoRequest = new LoginCryptoRequest(...); ConioCredentials credentials = new ConioCredentials(\"username\", \"password\"); LoginParams params = LoginParams.createCryptoLogin(credentials, cryptoRequest); conio.userService.login(params) .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } ));","title":"Android"},{"location":"user/User/#ios_2","text":"let params = LoginParams(username: \"lemonade\", password: \"secretword\", loginCryptoRequest: <LoginCryptoRequest>) conio.userService.login(params: params).asCallback { result in switch result { case .success: // success case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"user/User/#logout","text":"Consente di disconnettere l'utenza Conio.","title":"Logout"},{"location":"user/User/#metodo_3","text":"userService.logout","title":"Metodo"},{"location":"user/User/#risposta_3","text":"Un oggetto di tipo Success che indica che l'utente \u00e8 stato disconnesso.","title":"Risposta"},{"location":"user/User/#codice_3","text":"","title":"Codice"},{"location":"user/User/#android_3","text":"conio.userService.logout() .asCallback(result -> result.analysis( success -> { /* Handle success */ }, error -> { /* Handle error */ } ));","title":"Android"},{"location":"user/User/#ios_3","text":"conio.userService.logout().asCallback { result in switch result { case .success: // success case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet.en/","text":"Italiano Wallet operations Bitcoin address Show one of the unused Bitcoin addresses of the wallet, that you can use to receive bitcoins. Returns A string containing the Bitcoin address. Code Android conio.walletService.currentBitcoinAddress(result->{ result.analysis(address-> { // String }, error-> { // Exception }); }); iOS conio.walletService.currentBitcoinAddress { result in result.analysis(ifSuccess: { address in // String }, ifFailure: { error in // ServiceError }) } Bitcoin Movement List Each transaction (send, receive, buy, sell) is represented by an Activity . You can get a list of these activites using the following method: Parameters An ActivitiesParams struct containing: index : You can get 6 activities at a time. The index is the starting point of the list you want. For example using an index = 0 means you will get the last 6 activities. Then you can repeat this with index 6 which will get you the activities right before. important : To get all the activities you just have to repeat this call until you get less than 6 activities. types : you can use types if you want to filter the activities. For example you want to get only the buy activities. currency : the fiat currency your activities will be priced in. Returns A WalletActivities struct containing: - activities : an array of Activity . Each activity has its own ID , a Type (send, buy, sell, receive), an amount in Satoshi , and a confirmationStatus which will let you know if a bitcoin transaction is included in the blockchain. Code Android // To retrieve all the activities ActivityType[] types = ActivityType.all() ActivitiesParams params = new ActivitiesParams(0, types, Currency.EUR); // To retrieve purchases and sells ActivityType[] types = new ActivityType[] { ActivityType.BUY, ActivityType.SELL }; ActivitiesParams params = new ActivitiesParams(0, types, Currency.EUR); conio.walletService.walletActivities(params, result->{ result.analysis(activities-> { // WalletActivities }, error-> { // Exception }); }); iOS // To retrieve all the activities let params = ActivitiesParams( index: 0, types: ActivityType.all currency: .eur ) // To retrieve only purchases and sells let params = ActivitiesParams( index: 0, types: [.buy, .sell] currency: .eur ) conio.walletService.walletActivities(params: activitiesParams) { result in result.analysis(ifSuccess: { activities in // WalletActivities }, ifFailure: { error in // ServiceError }) } Activity detail You can get all the info about a single activity by using this method. Parameters An ActivityDetailsParams containing: activityId : the identifier of the activity you want to get the details of. currency : the fiat currency your activity will be priced in. Returns An ActivityDetails containing: id : identifier of the activity type : activity type timestamp : timestamp when the activity was created @Optional transaction : the info about the Bitcoin transaction related to that activity. Contains info like the hash of the transaction, number of confirmations, the Bitcoin address that is receiving the Bitcoin, the fiat currency equivalent, the fees payed and more. @Optional bid : info about the bid. Contains all the info about the purchase. @Optional payment : info about the payment, including the id of the payment method, the value of the payment and its status. @Optional ask : info about the ask. Contains all the info about the sell. @Optional sell : info about the wire transfer, the identifier , cro Code Android ActivityDetailsParams params = new ActivityDetailsParams(\"id\", Currency.EUR); conio.walletService.activityDetails(params, result->{ result.analysis(details-> { // ActivityDetails }, error-> { // Exception }); }); iOS let params = ActivityDetailsParams(activityId: \"activityId\", currency: .eur) conio.walletService.activityDetails(params: params) { result in result.analysis(ifSuccess: { details in // ActivityDetails }, ifFailure: { error in // ServiceError }) } Wallet balance You can get the balance of the wallet. Returns A WalletDetails containing the amount of Bitcoin in the wallet (the amount is expressed in satoshi, the smallest unit of Bitcoin) (1 bitcoin = 100.000.000) confirmedBalance : bitcoins that have at least 3 confirmations on the blockchain and that the user can send/sell unconfirmedBalance : bitcoins with less than 3 confirmations, that the user can't spend yet Code Android conio.walletService.walletdetails(result->{ result.analysis(details-> { // WalletDetails }, error-> { // Exception }); }); iOS conio.walletService.walletDetails { result in result.analysis(ifSuccess: { details in // WalletDetails }, ifFailure: { error in // ServiceError }) } Send Bitcoin With this SDK you can send bitcoins to any other Bitcoin wallet. There is also a second factor to protect the operation. Get sendable Max Amount First of all you will need to fetch the maximum amount the user can send, which is equal to the amount in their wallet minus the mining fees. Conio will give you exactly the maximum amount in Satoshis that the user can send if you make a WithdrawalFees request if you simply pass the destAddress Get mining fees If the user inputs an amount lower or equal to the Max Amount you can then request the available mining-fees speeds. Conio has an algorithm that you can use. Parameters A WithdrawalFeesParams struct: destAddress : the address that will receive the bitcoins amount : the bitcoin amount, in Satoshi. If you input 0 you will get the fees as if you were sending the maximum amount in the wallet speed : a specific speed (1 faster, 5 slower), if you don't specify a speed (priority) you will get an array with all the available speeds. Which params should you use? To get the Max amount : you just have to pass the destAddress To get the Available Fees : You have to use destAddress and amount . The resulting array cointains all the available speeds. Return An AvailableWithdrawalFees struct containing: absoluteFees : total amount of the mining fees expressed in satoshi amount : the amount, expressed in satoshi, that the user can send at the requested speed feePerByte : transaction size (bytes)/ absoluteFees = feePerByte transactionSpeed : transaction priority availableFees : an array contaning all the possible speeds Errors NOT_ENOUGH_BTC_AMOUNT DUST_TRANSACTION the amount you are trying to send is too small NO_SUCH_WITHDRAWAL_FEES_INFO: Can't calculate the mining fees iOS example // maximum amount you can send (speed 5) let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\") // all the available speeds for a set amount: 10000 satoshi let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: 10_000) // send everything with the fastest speed (speed 1) let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: 0, speed: .transactionSpeedType1) conio.walletService.withdrawalFees { result in result.analysis(ifSuccess: { availableFees in // availableFees }, ifFailure: { error in // ServiceError }) } Android example // maximum amount you can send (speed 5) let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\") // all the available speeds for a set amount: 10000 satoshi let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: 10_000) // send everything with the fastest speed (speed 1) WithdrawalFeesParams params = new WithdrawalFeesParams(\"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 0L, TransactionSpeedType.SPEED_ONE); conio.walletService.withdrawalFees(params, response -> { response.analysis(availableFees -> { // availableFees }, error -> { // ServiceError }); }); Finalize Send - second factor Now that you have the feePerByte you can finally send the bitcoins using the following method. After the first attempt you will receive an error asking for a 2fa code. The user will receive an email with the code that can be used for 5 minutes . You will pass this code to the SDK in the parameters of the same method. Parameters for the first attempt Use a TransactionParams struct: address : Bitcoin address amount : satoshi amount of the transaction fee : mining fee Satoshi per byte iOS let params = TransactionParams( address: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: UInt64(1000), feePerByte: UInt64(10) ) conio.walletService.sendTransaction(params) { result in result.analysis(ifSuccess: { sentTransaction in // ... }, ifFailure: { error in // Get the mfa token if case let .mfaRequired(token: token) = error { let mfaToken = token } }) } Android // Chiamata senza Codice MFA ed MFA Token TransactionParams params = new TransactionParams( \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 1000L, 10L ); conio.walletService.sendTransaction(params, result -> { result.analysis(sentTransaction -> { // ... }, error -> { // Get the mfa token if (error instanceof MfaRequiredException) { MfaRequiredException mfaRequiredException = (MfaRequiredException) error; String mfaToken = mfaRequiredException.getMfaToken(); } } }); }); Optional deep link The user can click on a deep link found in their email like this one: conio-internal://request_btc_withdrawal?code=<MFACode> To avoid losing data when the user puts the app in background and then clicks on the deep link, you can save the info about the send (amount, address and fees) in the memory of the device. Parameters for the second attempt To send Bitcoin you can use a TransactionParams struct: address : Bitcoin address amount : satoshi amount of the transaction fee : mining fee Satoshi per byte mfaCode : the code that the user received in their email after the first attempt Returns A SentTransaction containing: transactionId : transaction identifier fee : payed mining fees Errors [iOS] ServiceError.mfaRequired : No mfaCode used or the code is incorrect. The user will receive a new code. [Android] ConioError.MFA_REQUIRED : No mfaCode used or the code is incorrect. The user will receive a new code. NOT_ENOUGH_BTC_AMOUNT DUST_TRANSACTION the amount you are trying to send is too small INVALID_MESSAGE_SIGNATURE iOS example let params = TransactionParams( address: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: UInt64(1000), feePerByte: UInt64(10), mfaToken: \"OciqYgdjxJV413iHkFqgUYGk\", mfaCode: \"806157\" ) conio.walletService.sendTransaction(params) { result in result.analysis(ifSuccess: { sentTransaction in // SentTransaction }, ifFailure: { error in // ServiceError }) } Android example // MFA e MFA Token TransactionParams params = new TransactionParams( \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 1000L, 10L, \"OciqYgdjxJV413iHkFqgUYGk\", \"806157\" ); conio.walletService.sendTransaction(params, result -> { result.analysis(sentTransaction -> { // SentTransaction }, error -> { // Exception }); }); Wallet backup code Show the wallet backup code: a list of 12 words. Returns A MnemonicWords containing an array with 12 strings in it. Errors missingMnemonic : failed to retrieve the backup code Android conio.walletService.readMnemonic(result->{ result.analysis(mnemonicWords-> { // MnemonicWords }, error-> { // Exception }); }); iOS conio.walletService.readMnemonic { result in result.analysis(ifSuccess: { mnemonicWords in // MnemonicWords }, ifFailure: { error in // ServiceError }) }","title":"Wallet operations"},{"location":"wallet/Wallet.en/#wallet-operations","text":"","title":"Wallet operations"},{"location":"wallet/Wallet.en/#bitcoin-address","text":"Show one of the unused Bitcoin addresses of the wallet, that you can use to receive bitcoins.","title":"Bitcoin address"},{"location":"wallet/Wallet.en/#returns","text":"A string containing the Bitcoin address.","title":"Returns"},{"location":"wallet/Wallet.en/#code","text":"","title":"Code"},{"location":"wallet/Wallet.en/#android","text":"conio.walletService.currentBitcoinAddress(result->{ result.analysis(address-> { // String }, error-> { // Exception }); });","title":"Android"},{"location":"wallet/Wallet.en/#ios","text":"conio.walletService.currentBitcoinAddress { result in result.analysis(ifSuccess: { address in // String }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"wallet/Wallet.en/#bitcoin-movement-list","text":"Each transaction (send, receive, buy, sell) is represented by an Activity . You can get a list of these activites using the following method:","title":"Bitcoin Movement List"},{"location":"wallet/Wallet.en/#parameters","text":"An ActivitiesParams struct containing: index : You can get 6 activities at a time. The index is the starting point of the list you want. For example using an index = 0 means you will get the last 6 activities. Then you can repeat this with index 6 which will get you the activities right before. important : To get all the activities you just have to repeat this call until you get less than 6 activities. types : you can use types if you want to filter the activities. For example you want to get only the buy activities. currency : the fiat currency your activities will be priced in.","title":"Parameters"},{"location":"wallet/Wallet.en/#returns_1","text":"A WalletActivities struct containing: - activities : an array of Activity . Each activity has its own ID , a Type (send, buy, sell, receive), an amount in Satoshi , and a confirmationStatus which will let you know if a bitcoin transaction is included in the blockchain.","title":"Returns"},{"location":"wallet/Wallet.en/#code_1","text":"","title":"Code"},{"location":"wallet/Wallet.en/#android_1","text":"// To retrieve all the activities ActivityType[] types = ActivityType.all() ActivitiesParams params = new ActivitiesParams(0, types, Currency.EUR); // To retrieve purchases and sells ActivityType[] types = new ActivityType[] { ActivityType.BUY, ActivityType.SELL }; ActivitiesParams params = new ActivitiesParams(0, types, Currency.EUR); conio.walletService.walletActivities(params, result->{ result.analysis(activities-> { // WalletActivities }, error-> { // Exception }); });","title":"Android"},{"location":"wallet/Wallet.en/#ios_1","text":"// To retrieve all the activities let params = ActivitiesParams( index: 0, types: ActivityType.all currency: .eur ) // To retrieve only purchases and sells let params = ActivitiesParams( index: 0, types: [.buy, .sell] currency: .eur ) conio.walletService.walletActivities(params: activitiesParams) { result in result.analysis(ifSuccess: { activities in // WalletActivities }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"wallet/Wallet.en/#activity-detail","text":"You can get all the info about a single activity by using this method.","title":"Activity detail"},{"location":"wallet/Wallet.en/#parameters_1","text":"An ActivityDetailsParams containing: activityId : the identifier of the activity you want to get the details of. currency : the fiat currency your activity will be priced in.","title":"Parameters"},{"location":"wallet/Wallet.en/#returns_2","text":"An ActivityDetails containing: id : identifier of the activity type : activity type timestamp : timestamp when the activity was created @Optional transaction : the info about the Bitcoin transaction related to that activity. Contains info like the hash of the transaction, number of confirmations, the Bitcoin address that is receiving the Bitcoin, the fiat currency equivalent, the fees payed and more. @Optional bid : info about the bid. Contains all the info about the purchase. @Optional payment : info about the payment, including the id of the payment method, the value of the payment and its status. @Optional ask : info about the ask. Contains all the info about the sell. @Optional sell : info about the wire transfer, the identifier , cro","title":"Returns"},{"location":"wallet/Wallet.en/#code_2","text":"","title":"Code"},{"location":"wallet/Wallet.en/#android_2","text":"ActivityDetailsParams params = new ActivityDetailsParams(\"id\", Currency.EUR); conio.walletService.activityDetails(params, result->{ result.analysis(details-> { // ActivityDetails }, error-> { // Exception }); });","title":"Android"},{"location":"wallet/Wallet.en/#ios_2","text":"let params = ActivityDetailsParams(activityId: \"activityId\", currency: .eur) conio.walletService.activityDetails(params: params) { result in result.analysis(ifSuccess: { details in // ActivityDetails }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"wallet/Wallet.en/#wallet-balance","text":"You can get the balance of the wallet.","title":"Wallet balance"},{"location":"wallet/Wallet.en/#returns_3","text":"A WalletDetails containing the amount of Bitcoin in the wallet (the amount is expressed in satoshi, the smallest unit of Bitcoin) (1 bitcoin = 100.000.000) confirmedBalance : bitcoins that have at least 3 confirmations on the blockchain and that the user can send/sell unconfirmedBalance : bitcoins with less than 3 confirmations, that the user can't spend yet","title":"Returns"},{"location":"wallet/Wallet.en/#code_3","text":"","title":"Code"},{"location":"wallet/Wallet.en/#android_3","text":"conio.walletService.walletdetails(result->{ result.analysis(details-> { // WalletDetails }, error-> { // Exception }); });","title":"Android"},{"location":"wallet/Wallet.en/#ios_3","text":"conio.walletService.walletDetails { result in result.analysis(ifSuccess: { details in // WalletDetails }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"wallet/Wallet.en/#send-bitcoin","text":"With this SDK you can send bitcoins to any other Bitcoin wallet. There is also a second factor to protect the operation.","title":"Send Bitcoin"},{"location":"wallet/Wallet.en/#get-sendable-max-amount","text":"First of all you will need to fetch the maximum amount the user can send, which is equal to the amount in their wallet minus the mining fees. Conio will give you exactly the maximum amount in Satoshis that the user can send if you make a WithdrawalFees request if you simply pass the destAddress","title":"Get sendable Max Amount"},{"location":"wallet/Wallet.en/#get-mining-fees","text":"If the user inputs an amount lower or equal to the Max Amount you can then request the available mining-fees speeds. Conio has an algorithm that you can use.","title":"Get mining fees"},{"location":"wallet/Wallet.en/#parameters_2","text":"A WithdrawalFeesParams struct: destAddress : the address that will receive the bitcoins amount : the bitcoin amount, in Satoshi. If you input 0 you will get the fees as if you were sending the maximum amount in the wallet speed : a specific speed (1 faster, 5 slower), if you don't specify a speed (priority) you will get an array with all the available speeds.","title":"Parameters"},{"location":"wallet/Wallet.en/#which-params-should-you-use","text":"To get the Max amount : you just have to pass the destAddress To get the Available Fees : You have to use destAddress and amount . The resulting array cointains all the available speeds.","title":"Which params should you use?"},{"location":"wallet/Wallet.en/#return","text":"An AvailableWithdrawalFees struct containing: absoluteFees : total amount of the mining fees expressed in satoshi amount : the amount, expressed in satoshi, that the user can send at the requested speed feePerByte : transaction size (bytes)/ absoluteFees = feePerByte transactionSpeed : transaction priority availableFees : an array contaning all the possible speeds","title":"Return"},{"location":"wallet/Wallet.en/#errors","text":"NOT_ENOUGH_BTC_AMOUNT DUST_TRANSACTION the amount you are trying to send is too small NO_SUCH_WITHDRAWAL_FEES_INFO: Can't calculate the mining fees","title":"Errors"},{"location":"wallet/Wallet.en/#ios-example","text":"// maximum amount you can send (speed 5) let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\") // all the available speeds for a set amount: 10000 satoshi let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: 10_000) // send everything with the fastest speed (speed 1) let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: 0, speed: .transactionSpeedType1) conio.walletService.withdrawalFees { result in result.analysis(ifSuccess: { availableFees in // availableFees }, ifFailure: { error in // ServiceError }) }","title":"iOS example"},{"location":"wallet/Wallet.en/#android-example","text":"// maximum amount you can send (speed 5) let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\") // all the available speeds for a set amount: 10000 satoshi let params = WithdrawalFeesParams(destAddress: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: 10_000) // send everything with the fastest speed (speed 1) WithdrawalFeesParams params = new WithdrawalFeesParams(\"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 0L, TransactionSpeedType.SPEED_ONE); conio.walletService.withdrawalFees(params, response -> { response.analysis(availableFees -> { // availableFees }, error -> { // ServiceError }); });","title":"Android example"},{"location":"wallet/Wallet.en/#finalize-send-second-factor","text":"Now that you have the feePerByte you can finally send the bitcoins using the following method. After the first attempt you will receive an error asking for a 2fa code. The user will receive an email with the code that can be used for 5 minutes . You will pass this code to the SDK in the parameters of the same method.","title":"Finalize Send - second factor"},{"location":"wallet/Wallet.en/#parameters-for-the-first-attempt","text":"Use a TransactionParams struct: address : Bitcoin address amount : satoshi amount of the transaction fee : mining fee Satoshi per byte","title":"Parameters for the first attempt"},{"location":"wallet/Wallet.en/#ios_4","text":"let params = TransactionParams( address: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: UInt64(1000), feePerByte: UInt64(10) ) conio.walletService.sendTransaction(params) { result in result.analysis(ifSuccess: { sentTransaction in // ... }, ifFailure: { error in // Get the mfa token if case let .mfaRequired(token: token) = error { let mfaToken = token } }) }","title":"iOS"},{"location":"wallet/Wallet.en/#android_4","text":"// Chiamata senza Codice MFA ed MFA Token TransactionParams params = new TransactionParams( \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 1000L, 10L ); conio.walletService.sendTransaction(params, result -> { result.analysis(sentTransaction -> { // ... }, error -> { // Get the mfa token if (error instanceof MfaRequiredException) { MfaRequiredException mfaRequiredException = (MfaRequiredException) error; String mfaToken = mfaRequiredException.getMfaToken(); } } }); });","title":"Android"},{"location":"wallet/Wallet.en/#optional-deep-link","text":"The user can click on a deep link found in their email like this one: conio-internal://request_btc_withdrawal?code=<MFACode> To avoid losing data when the user puts the app in background and then clicks on the deep link, you can save the info about the send (amount, address and fees) in the memory of the device.","title":"Optional deep link"},{"location":"wallet/Wallet.en/#parameters-for-the-second-attempt","text":"To send Bitcoin you can use a TransactionParams struct: address : Bitcoin address amount : satoshi amount of the transaction fee : mining fee Satoshi per byte mfaCode : the code that the user received in their email after the first attempt","title":"Parameters for the second attempt"},{"location":"wallet/Wallet.en/#returns_4","text":"A SentTransaction containing: transactionId : transaction identifier fee : payed mining fees","title":"Returns"},{"location":"wallet/Wallet.en/#errors_1","text":"[iOS] ServiceError.mfaRequired : No mfaCode used or the code is incorrect. The user will receive a new code. [Android] ConioError.MFA_REQUIRED : No mfaCode used or the code is incorrect. The user will receive a new code. NOT_ENOUGH_BTC_AMOUNT DUST_TRANSACTION the amount you are trying to send is too small INVALID_MESSAGE_SIGNATURE","title":"Errors"},{"location":"wallet/Wallet.en/#ios-example_1","text":"let params = TransactionParams( address: \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", amount: UInt64(1000), feePerByte: UInt64(10), mfaToken: \"OciqYgdjxJV413iHkFqgUYGk\", mfaCode: \"806157\" ) conio.walletService.sendTransaction(params) { result in result.analysis(ifSuccess: { sentTransaction in // SentTransaction }, ifFailure: { error in // ServiceError }) }","title":"iOS example"},{"location":"wallet/Wallet.en/#android-example_1","text":"// MFA e MFA Token TransactionParams params = new TransactionParams( \"mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\", 1000L, 10L, \"OciqYgdjxJV413iHkFqgUYGk\", \"806157\" ); conio.walletService.sendTransaction(params, result -> { result.analysis(sentTransaction -> { // SentTransaction }, error -> { // Exception }); });","title":"Android example"},{"location":"wallet/Wallet.en/#wallet-backup-code","text":"Show the wallet backup code: a list of 12 words.","title":"Wallet backup code"},{"location":"wallet/Wallet.en/#returns_5","text":"A MnemonicWords containing an array with 12 strings in it.","title":"Returns"},{"location":"wallet/Wallet.en/#errors_2","text":"missingMnemonic : failed to retrieve the backup code","title":"Errors"},{"location":"wallet/Wallet.en/#android_5","text":"conio.walletService.readMnemonic(result->{ result.analysis(mnemonicWords-> { // MnemonicWords }, error-> { // Exception }); });","title":"Android"},{"location":"wallet/Wallet.en/#ios_5","text":"conio.walletService.readMnemonic { result in result.analysis(ifSuccess: { mnemonicWords in // MnemonicWords }, ifFailure: { error in // ServiceError }) }","title":"iOS"},{"location":"wallet/Wallet/","text":"English Operazioni sul portafoglio Indirizzo Bitcoin attuale Permette di recuperare l'indirizzo corrente del portafoglio su cui sar\u00e0 possibile ricevere delle transazioni. Metodo walletService.currentBitcoinAddress Risposta Una stringa contenente l'indirizzo Bitcoin attuale. Errori Non autorizzato Codice Android conio.walletService.currentBitcoinAddress() .asCallback(result -> result.analysis( address -> {/* Handle string wallet address */ }, error -> { /* ... */ } )); iOS conio.walletService.currentBitcoinAddress().asCallback { result in switch result { case .success(let address): // Handle string wallet address case .failure(let error): // Operation Error } } Lista movimenti bitcoin Ciascuna operazione di invio, ricezione, acquisto e vendita di Bitcoin \u00e8 rappresentata da un' Activity . La lista delle attivit\u00e0 svolte dall'utente pu\u00f2 essere recuperata tramite l'apposito metodo. Metodo walletService.activityList Parametri Un oggetto di tipo ActivityListParams contenente: types : di tipo List<ActivityType> , una lista di enumerati ActivityType che ci permette di specificare le tipologie di activities da recuperare. Tramite ActivityType.all() \u00e8 possibile ottenere una lista di tutte le tipologie di Activity ; currency : di tipo Currency , la valuta nella quale si vuole conoscere il valore della transazioni di acquisto e vendita (attualmente solo Euro); @Default(6) limit : di tipo intero , il numero massimo di transazioni da ricevere nella risposta; @Opzionale nextPage : di tipo String , token per la paginazione delle activities, ottenibile tramite il risultato di una prima richiesta di lista movimenti con questo valore nullo. Inserendo tale valore \u00e8 possibile ottenere le successive n Activity (con n = valore inserito come limit ); @Opzionale timeFrame : di tipo TimeFrame , la finestra temporale che definisce quali Activity includere nella risposta. Risposta Un oggetto di tipo ActivityList contenente: activities : di tipo List<SimpleActivity> , ovvero la lista delle Activity dell'utente richieste; @Opzionale nextPage : di tipo String , token per la paginazione delle activity, che pu\u00f2 essere inserito in una successiva richiesta di lista movimenti . Quando questo campo \u00e8 nullo, significa che non esistono ulteriori Activity tra quelle che rispettano i filtri inseriti. Ogni Activity resituita (di tipo SimpleActivity ) contiene: activityId : di tipo String , l'identificativo univoco della Activity ; type : di tipo ActivityType , la tipologia di Activity ( SEND , BUY , SELL , RECEIVE ); status : di tipo TransactionStatus , lo stato di conferma della transazione Bitcoin legata all' Activity ( UNCONFIRMED , PARTIALLY_CONFIRMED , CONFIRMED ); createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi. cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi), movimentato dall' Activity ; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il corrispettivo ammontare di cryptoAmount , calcolato nella valuta indicata tramite il campo currency ; Errori Non autorizzato Codice Android // Example 1: retrieve 6 activities of all type List<ActivityType> types = ActivityType.all; ActivityListParams params = new ActivityListParams(types, Currency.EUR); // Example 2: retrieve 10 sell activities List<ActivityType> types = Collections.singletonList(ActivityType.SELL); ActivityListParams params = new ActivityListParams(types, Currency.EUR, 10); // Example 3: retrieve 6 buy and receive activities of the last month List<ActivityType> types = Arrays.asList(ActivityType.BUY, ActivityType.RECEIVE); ActivityListParams params = new ActivityListParams( types, // types Currency.EUR, // currency 6, // limit null, // nextPage TimeFrame.lastMonth() // timeFrame ); conio.walletService.activityList(params) .asCallback(result -> result.analysis( activityList -> { /* Handle ActivityList */ }, error -> { /* ... */ } )); iOS let types = WalletActivityType.allCases let params = ActivitiesParams(nextPage: \"string\", types: types) conio.walletService.walletActivities(params: params).asCallback { result in switch result { case .success(let activities): // WalletActivities case .failure(let error): // Operation Error } } Dettaglio di un movimento Recuperata la lista delle attivit\u00e0 \u00e8 possibile ottenere ulteriori informazioni su un Activity specifica richiedendone il dettaglio. Metodo walletService.activityDetails Parametri Un oggetto di tipo ActivityDetailsParams contenente: activityId : di tipo String , l'id dell' Activity della quale si vuole leggere il dettaglio; currency : di tipo Currency , la valuta nella quale si vuole conoscere il valore della transazioni di acquisto e vendita (attualmente solo Euro); Risposta Un oggetto di tipo ActivityDetails contenente: activityId : di tipo String , l'id dell'attivit\u00e0; type : di tipo ActivityType , la tipologia di Activity ( SEND , BUY , SELL , RECEIVE ); createdAt : di tipo Long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi. @Opzionale transaction : di tipo Transaction , la transazione annessa. Popolato nel caso in cui sia stata effettuata una transazione. Contiene informazioni sulla transazione Bitcoin associata all' Activity , quali: hash : di tipo String , l'hash della transazione Bitcoin; status : di tipo TransactionStatus , lo stato di conferma della transazione Bitcoin legata all' Activity ( UNCONFIRMED , PARTIALLY_CONFIRMED , CONFIRMED ); type : di tipo TransactionType , il tipo di transazione Bitcoin ( GENERIC o REDEPOSIT , ovvero una transazione verso se stessi); addresses : di tipo List<String> , gli indirizzi Bitcoin dei dei mittenti (per le transazioni in entrata) o dei destinatari (per le transazioni in uscita); cryptoAmount : di tipo long miningFees : di tipo long , le commissioni pagate alle rete Bitcoin per processare la transazione; isIncoming : di tipo booleano , flag indicante se la transazione \u00e8 in entrata o in uscita rispetto al portafoglio dell'utente; isLocal : di tipo booleano , flag indicante se la transazione \u00e8 stata ricevuta/inviata da/a un portafoglio Conio. @Opzionale associatedBid : l'offerta di acquisto annessa. Popolato in caso di attivit\u00e0 di acquisto. Contiene le informazioni sulla richiesta di acquisto, quali: status : di tipo BidStatus , lo stato del pagamento della richiesta di acquisto ( PAID , CHARGED ); cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) acquistato; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il controvalore (rispetto al cryptoAmount ) accordato per l'acquisto dei bitcoin, calcolato nella valuta indicata dal campo currency ; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni pagate per la fruizione del servizio, calcolato nella valuta indicata dal campo currency ; currency : di tipo Currency , la valuta usata per l'acquisto dei bitcoin; paymentMethodId : di tipo String , l'identificativo del metodo di pagamento; createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi; paidAt : di tipo long , l'istante temporale in cui \u00e8 stato effettuato il pagamento per l'acquisto dei bitcoin, espresso come Unix Timestamp in millisecondi; @Opzionale chargedAt : di tipo long , l'istante temporale in cui \u00e8 stata invaita la transazione bitcoin, espresso come Unix Timestamp in millisecondi. Nullo nel caso in cui la transazione non sia ancora stata effettuata. @Opzionale associatedAsk : l'offerta di vendita annessa. Popolato in caso di attivit\u00e0 di vendita, Contiene le informazioni sulla richeista di vendita, quali: status : di tipo AskStatus , lo stato del pagamento della richiesta di vendita ( CHARGED , PAID ) cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) venduto; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il controvalore (rispetto al cryptoAmount ) accordato per la vendita dei bitcoin, calcolato nella valuta indicata dal campo currency ; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni pagate per la fruizione del servizio, calcolato nella valuta indicata dal campo currency ; currency : di tipo Currency , la valuta usata per la vendita dei bitcoin; sellMethodId : di tipo String , l'identificativo del metodo di riscossione della vendita; cro : di tipo String , il Codice Riferimento Operazione della transazione bancaria; iban : di tipo String , l'IBAN del richiedente del bonifico bancario; createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi; chargedAt : di tipo long , l'istante temporale in cui \u00e8 stata invaita la transazione bitcoin, espresso come Unix Timestamp in millisecondi; @Opzionale paidAt : di tipo long , l'istante temporale in cui \u00e8 stato effettuato il pagamento per la vendita dei bitcoin, espresso come Unix Timestamp in millisecondi. Nullo nel caso in cui la transazione non sia ancora stata effettuata. Errori Non autorizzato Codice Android ActivityDetailsParams params = new ActivityDetailsParams(\"activityId\", Currency.EUR); conio.walletService.activityDetails(params) .asCallback(result -> result.analysis( details -> { /* Handle ActivityDetails */ }, error -> { /* ... */ } )); iOS let params = ActivityDetailsParams(activityId: \"activityId\", currency: .eur) conio.walletService.activityDetails(params: params).asCallback { result in switch result { case .success(let details): // ActivityDetails case .failure(let error): // Operation Error } } Bilancio del portafoglio Permette di recuperare il bilancio del portafoglio Bitcoin dell'utente. Metodo walletService.walletBalances Risposta Un oggetto di tipo WalletBalances contenente il valore di bitcoin presente nel wallet espresso in satoshi (1 bitcoin = 100.000.000 satoshi). Il valore si divide in: confirmedBalance : di tipo long , valore con almeno 3 conferme sulla blockchain Bitcoin e quindi disponibile per l'utente; unconfirmedBalance : di tipo long , valore con meno di 3 conferme e quindi non ancora disponibile. Errori Non autorizzato Codice Android conio.walletService.walletBalances() .asCallback(result -> result.analysis( balances -> { /* Handle WalletBalances */ }, error -> { /* ... */ } )); iOS conio.walletService.walletBalances().asCallback { result in switch result { case .success(let balances): // WalletBalances case .failure(let error): // Operation Error } } Codice di recupero Bitcoin Permette di recuperare dalla memoria del dispositivo il \"Codie di recupero Bitcoin\": 12 parole di backup del portafoglio Bitcoin. Risposta Un oggetto di tipo MnemonicWords contenente un array di 12 stringhe. Errori Non autorizzato Codice Android conio.walletService.readMnemonic() .asCallback(result -> result.analysis( mnemonic -> { /* Handle MnemonicWords */ }, error -> { /* ... */ } )); iOS conio.walletService.readMnemonic().asCallback { result in switch result { case .success(let mnemonic): // MnemonicWords case .failure(let error): // Operation Error } }","title":"Operazioni sul portafoglio"},{"location":"wallet/Wallet/#operazioni-sul-portafoglio","text":"","title":"Operazioni sul portafoglio"},{"location":"wallet/Wallet/#indirizzo-bitcoin-attuale","text":"Permette di recuperare l'indirizzo corrente del portafoglio su cui sar\u00e0 possibile ricevere delle transazioni.","title":"Indirizzo Bitcoin attuale"},{"location":"wallet/Wallet/#metodo","text":"walletService.currentBitcoinAddress","title":"Metodo"},{"location":"wallet/Wallet/#risposta","text":"Una stringa contenente l'indirizzo Bitcoin attuale.","title":"Risposta"},{"location":"wallet/Wallet/#errori","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice","text":"","title":"Codice"},{"location":"wallet/Wallet/#android","text":"conio.walletService.currentBitcoinAddress() .asCallback(result -> result.analysis( address -> {/* Handle string wallet address */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios","text":"conio.walletService.currentBitcoinAddress().asCallback { result in switch result { case .success(let address): // Handle string wallet address case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/#lista-movimenti-bitcoin","text":"Ciascuna operazione di invio, ricezione, acquisto e vendita di Bitcoin \u00e8 rappresentata da un' Activity . La lista delle attivit\u00e0 svolte dall'utente pu\u00f2 essere recuperata tramite l'apposito metodo.","title":"Lista movimenti bitcoin"},{"location":"wallet/Wallet/#metodo_1","text":"walletService.activityList","title":"Metodo"},{"location":"wallet/Wallet/#parametri","text":"Un oggetto di tipo ActivityListParams contenente: types : di tipo List<ActivityType> , una lista di enumerati ActivityType che ci permette di specificare le tipologie di activities da recuperare. Tramite ActivityType.all() \u00e8 possibile ottenere una lista di tutte le tipologie di Activity ; currency : di tipo Currency , la valuta nella quale si vuole conoscere il valore della transazioni di acquisto e vendita (attualmente solo Euro); @Default(6) limit : di tipo intero , il numero massimo di transazioni da ricevere nella risposta; @Opzionale nextPage : di tipo String , token per la paginazione delle activities, ottenibile tramite il risultato di una prima richiesta di lista movimenti con questo valore nullo. Inserendo tale valore \u00e8 possibile ottenere le successive n Activity (con n = valore inserito come limit ); @Opzionale timeFrame : di tipo TimeFrame , la finestra temporale che definisce quali Activity includere nella risposta.","title":"Parametri"},{"location":"wallet/Wallet/#risposta_1","text":"Un oggetto di tipo ActivityList contenente: activities : di tipo List<SimpleActivity> , ovvero la lista delle Activity dell'utente richieste; @Opzionale nextPage : di tipo String , token per la paginazione delle activity, che pu\u00f2 essere inserito in una successiva richiesta di lista movimenti . Quando questo campo \u00e8 nullo, significa che non esistono ulteriori Activity tra quelle che rispettano i filtri inseriti. Ogni Activity resituita (di tipo SimpleActivity ) contiene: activityId : di tipo String , l'identificativo univoco della Activity ; type : di tipo ActivityType , la tipologia di Activity ( SEND , BUY , SELL , RECEIVE ); status : di tipo TransactionStatus , lo stato di conferma della transazione Bitcoin legata all' Activity ( UNCONFIRMED , PARTIALLY_CONFIRMED , CONFIRMED ); createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi. cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi), movimentato dall' Activity ; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il corrispettivo ammontare di cryptoAmount , calcolato nella valuta indicata tramite il campo currency ;","title":"Risposta"},{"location":"wallet/Wallet/#errori_1","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice_1","text":"","title":"Codice"},{"location":"wallet/Wallet/#android_1","text":"// Example 1: retrieve 6 activities of all type List<ActivityType> types = ActivityType.all; ActivityListParams params = new ActivityListParams(types, Currency.EUR); // Example 2: retrieve 10 sell activities List<ActivityType> types = Collections.singletonList(ActivityType.SELL); ActivityListParams params = new ActivityListParams(types, Currency.EUR, 10); // Example 3: retrieve 6 buy and receive activities of the last month List<ActivityType> types = Arrays.asList(ActivityType.BUY, ActivityType.RECEIVE); ActivityListParams params = new ActivityListParams( types, // types Currency.EUR, // currency 6, // limit null, // nextPage TimeFrame.lastMonth() // timeFrame ); conio.walletService.activityList(params) .asCallback(result -> result.analysis( activityList -> { /* Handle ActivityList */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios_1","text":"let types = WalletActivityType.allCases let params = ActivitiesParams(nextPage: \"string\", types: types) conio.walletService.walletActivities(params: params).asCallback { result in switch result { case .success(let activities): // WalletActivities case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/#dettaglio-di-un-movimento","text":"Recuperata la lista delle attivit\u00e0 \u00e8 possibile ottenere ulteriori informazioni su un Activity specifica richiedendone il dettaglio.","title":"Dettaglio di un movimento"},{"location":"wallet/Wallet/#metodo_2","text":"walletService.activityDetails","title":"Metodo"},{"location":"wallet/Wallet/#parametri_1","text":"Un oggetto di tipo ActivityDetailsParams contenente: activityId : di tipo String , l'id dell' Activity della quale si vuole leggere il dettaglio; currency : di tipo Currency , la valuta nella quale si vuole conoscere il valore della transazioni di acquisto e vendita (attualmente solo Euro);","title":"Parametri"},{"location":"wallet/Wallet/#risposta_2","text":"Un oggetto di tipo ActivityDetails contenente: activityId : di tipo String , l'id dell'attivit\u00e0; type : di tipo ActivityType , la tipologia di Activity ( SEND , BUY , SELL , RECEIVE ); createdAt : di tipo Long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi. @Opzionale transaction : di tipo Transaction , la transazione annessa. Popolato nel caso in cui sia stata effettuata una transazione. Contiene informazioni sulla transazione Bitcoin associata all' Activity , quali: hash : di tipo String , l'hash della transazione Bitcoin; status : di tipo TransactionStatus , lo stato di conferma della transazione Bitcoin legata all' Activity ( UNCONFIRMED , PARTIALLY_CONFIRMED , CONFIRMED ); type : di tipo TransactionType , il tipo di transazione Bitcoin ( GENERIC o REDEPOSIT , ovvero una transazione verso se stessi); addresses : di tipo List<String> , gli indirizzi Bitcoin dei dei mittenti (per le transazioni in entrata) o dei destinatari (per le transazioni in uscita); cryptoAmount : di tipo long miningFees : di tipo long , le commissioni pagate alle rete Bitcoin per processare la transazione; isIncoming : di tipo booleano , flag indicante se la transazione \u00e8 in entrata o in uscita rispetto al portafoglio dell'utente; isLocal : di tipo booleano , flag indicante se la transazione \u00e8 stata ricevuta/inviata da/a un portafoglio Conio. @Opzionale associatedBid : l'offerta di acquisto annessa. Popolato in caso di attivit\u00e0 di acquisto. Contiene le informazioni sulla richiesta di acquisto, quali: status : di tipo BidStatus , lo stato del pagamento della richiesta di acquisto ( PAID , CHARGED ); cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) acquistato; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il controvalore (rispetto al cryptoAmount ) accordato per l'acquisto dei bitcoin, calcolato nella valuta indicata dal campo currency ; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni pagate per la fruizione del servizio, calcolato nella valuta indicata dal campo currency ; currency : di tipo Currency , la valuta usata per l'acquisto dei bitcoin; paymentMethodId : di tipo String , l'identificativo del metodo di pagamento; createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi; paidAt : di tipo long , l'istante temporale in cui \u00e8 stato effettuato il pagamento per l'acquisto dei bitcoin, espresso come Unix Timestamp in millisecondi; @Opzionale chargedAt : di tipo long , l'istante temporale in cui \u00e8 stata invaita la transazione bitcoin, espresso come Unix Timestamp in millisecondi. Nullo nel caso in cui la transazione non sia ancora stata effettuata. @Opzionale associatedAsk : l'offerta di vendita annessa. Popolato in caso di attivit\u00e0 di vendita, Contiene le informazioni sulla richeista di vendita, quali: status : di tipo AskStatus , lo stato del pagamento della richiesta di vendita ( CHARGED , PAID ) cryptoAmount : di tipo long , l'ammontare in satoshi (1 bitcoin = 100.000.000 satoshi) venduto; fiatAmount : di tipo Decimal (iOS) / BigDecimal (Android), il controvalore (rispetto al cryptoAmount ) accordato per la vendita dei bitcoin, calcolato nella valuta indicata dal campo currency ; serviceFee : di tipo Decimal (iOS) / BigDecimal (Android), le commissioni pagate per la fruizione del servizio, calcolato nella valuta indicata dal campo currency ; currency : di tipo Currency , la valuta usata per la vendita dei bitcoin; sellMethodId : di tipo String , l'identificativo del metodo di riscossione della vendita; cro : di tipo String , il Codice Riferimento Operazione della transazione bancaria; iban : di tipo String , l'IBAN del richiedente del bonifico bancario; createdAt : di tipo long , l'istante temporale in cui \u00e8 stata creata l' Activity , espresso come Unix Timestamp in millisecondi; chargedAt : di tipo long , l'istante temporale in cui \u00e8 stata invaita la transazione bitcoin, espresso come Unix Timestamp in millisecondi; @Opzionale paidAt : di tipo long , l'istante temporale in cui \u00e8 stato effettuato il pagamento per la vendita dei bitcoin, espresso come Unix Timestamp in millisecondi. Nullo nel caso in cui la transazione non sia ancora stata effettuata.","title":"Risposta"},{"location":"wallet/Wallet/#errori_2","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice_2","text":"","title":"Codice"},{"location":"wallet/Wallet/#android_2","text":"ActivityDetailsParams params = new ActivityDetailsParams(\"activityId\", Currency.EUR); conio.walletService.activityDetails(params) .asCallback(result -> result.analysis( details -> { /* Handle ActivityDetails */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios_2","text":"let params = ActivityDetailsParams(activityId: \"activityId\", currency: .eur) conio.walletService.activityDetails(params: params).asCallback { result in switch result { case .success(let details): // ActivityDetails case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/#bilancio-del-portafoglio","text":"Permette di recuperare il bilancio del portafoglio Bitcoin dell'utente.","title":"Bilancio del portafoglio"},{"location":"wallet/Wallet/#metodo_3","text":"walletService.walletBalances","title":"Metodo"},{"location":"wallet/Wallet/#risposta_3","text":"Un oggetto di tipo WalletBalances contenente il valore di bitcoin presente nel wallet espresso in satoshi (1 bitcoin = 100.000.000 satoshi). Il valore si divide in: confirmedBalance : di tipo long , valore con almeno 3 conferme sulla blockchain Bitcoin e quindi disponibile per l'utente; unconfirmedBalance : di tipo long , valore con meno di 3 conferme e quindi non ancora disponibile.","title":"Risposta"},{"location":"wallet/Wallet/#errori_3","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice_3","text":"","title":"Codice"},{"location":"wallet/Wallet/#android_3","text":"conio.walletService.walletBalances() .asCallback(result -> result.analysis( balances -> { /* Handle WalletBalances */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios_3","text":"conio.walletService.walletBalances().asCallback { result in switch result { case .success(let balances): // WalletBalances case .failure(let error): // Operation Error } }","title":"iOS"},{"location":"wallet/Wallet/#codice-di-recupero-bitcoin","text":"Permette di recuperare dalla memoria del dispositivo il \"Codie di recupero Bitcoin\": 12 parole di backup del portafoglio Bitcoin.","title":"Codice di recupero Bitcoin"},{"location":"wallet/Wallet/#risposta_4","text":"Un oggetto di tipo MnemonicWords contenente un array di 12 stringhe.","title":"Risposta"},{"location":"wallet/Wallet/#errori_4","text":"Non autorizzato","title":"Errori"},{"location":"wallet/Wallet/#codice_4","text":"","title":"Codice"},{"location":"wallet/Wallet/#android_4","text":"conio.walletService.readMnemonic() .asCallback(result -> result.analysis( mnemonic -> { /* Handle MnemonicWords */ }, error -> { /* ... */ } ));","title":"Android"},{"location":"wallet/Wallet/#ios_4","text":"conio.walletService.readMnemonic().asCallback { result in switch result { case .success(let mnemonic): // MnemonicWords case .failure(let error): // Operation Error } }","title":"iOS"}]}